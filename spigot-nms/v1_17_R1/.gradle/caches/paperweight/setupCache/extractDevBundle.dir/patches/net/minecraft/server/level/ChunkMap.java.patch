--- a/net/minecraft/server/level/ChunkMap.java
+++ b/net/minecraft/server/level/ChunkMap.java
@@ -1,7 +1,10 @@
 package net.minecraft.server.level;
 
+import co.aikar.timings.Timing; // Paper
+import com.destroystokyo.paper.PaperWorldConfig; // Paper
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.ComparisonChain; // Paper
 import com.google.common.collect.Lists;
 import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
@@ -12,25 +15,34 @@
 import it.unimi.dsi.fastutil.longs.Long2ByteMap;
 import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry;
 import it.unimi.dsi.fastutil.longs.LongIterator;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongSet;
-import it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry;
+import it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator;
+import it.unimi.dsi.fastutil.objects.ObjectIterator;
 import java.io.File;
 import java.io.IOException;
 import java.io.Writer;
 import java.util.BitSet;
+import java.util.HashMap; // Paper
+import java.util.Collection;
+import java.util.Iterator;
 import java.util.List;
+import java.util.Map; // Paper
 import java.util.Objects;
 import java.util.Optional;
 import java.util.Queue;
 import java.util.Set;
 import java.util.concurrent.CancellationException;
+import java.util.UUID; // Paper
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionException;
+import java.util.concurrent.CompletionStage;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.BooleanSupplier;
+import java.util.function.Consumer;
 import java.util.function.IntFunction;
 import java.util.function.IntSupplier;
 import java.util.function.Supplier;
@@ -50,6 +62,8 @@
 import net.minecraft.network.protocol.game.ClientboundSetEntityLinkPacket;
 import net.minecraft.network.protocol.game.ClientboundSetPassengersPacket;
 import net.minecraft.network.protocol.game.DebugPackets;
+import net.minecraft.server.MCUtil;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.progress.ChunkProgressListener;
 import net.minecraft.server.network.ServerPlayerConnection;
 import net.minecraft.util.CsvOutput;
@@ -65,6 +79,7 @@
 import net.minecraft.world.entity.boss.EnderDragonPart;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.GameRules;
+import net.minecraft.world.level.Level;
 import net.minecraft.world.level.chunk.ChunkAccess;
 import net.minecraft.world.level.chunk.ChunkGenerator;
 import net.minecraft.world.level.chunk.ChunkStatus;
@@ -75,17 +90,23 @@
 import net.minecraft.world.level.chunk.UpgradeData;
 import net.minecraft.world.level.chunk.storage.ChunkSerializer;
 import net.minecraft.world.level.chunk.storage.ChunkStorage;
+import net.minecraft.world.level.chunk.storage.RegionFile;
 import net.minecraft.world.level.entity.ChunkStatusUpdateListener;
 import net.minecraft.world.level.levelgen.structure.StructureStart;
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureManager;
 import net.minecraft.world.level.storage.DimensionDataStorage;
 import net.minecraft.world.level.storage.LevelStorageSource;
 import net.minecraft.world.phys.Vec3;
-import org.apache.commons.lang3.mutable.MutableBoolean;
+import it.unimi.dsi.fastutil.objects.ObjectRBTreeSet; // Paper
+import org.bukkit.craftbukkit.libs.org.apache.commons.lang3.mutable.MutableBoolean;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
+import org.bukkit.entity.Player; // CraftBukkit
+import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet; // Paper
+
 public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider {
+
     private static final byte CHUNK_TYPE_REPLACEABLE = -1;
     private static final byte CHUNK_TYPE_UNKNOWN = 0;
     private static final byte CHUNK_TYPE_FULL = 1;
@@ -94,88 +115,591 @@
     private static final int MIN_VIEW_DISTANCE = 3;
     public static final int MAX_VIEW_DISTANCE = 33;
     public static final int MAX_CHUNK_DISTANCE = 33 + ChunkStatus.maxDistance();
+    // Paper start - Don't copy
+    public final com.destroystokyo.paper.util.map.QueuedChangesMapLong2Object<ChunkHolder> updatingChunks = new com.destroystokyo.paper.util.map.QueuedChangesMapLong2Object<>();
+    // Paper end - Don't copy
     public static final int FORCED_TICKET_LEVEL = 31;
-    public final Long2ObjectLinkedOpenHashMap<ChunkHolder> updatingChunkMap = new Long2ObjectLinkedOpenHashMap<>();
-    public volatile Long2ObjectLinkedOpenHashMap<ChunkHolder> visibleChunkMap = this.updatingChunkMap.clone();
-    private final Long2ObjectLinkedOpenHashMap<ChunkHolder> pendingUnloads = new Long2ObjectLinkedOpenHashMap<>();
-    public final LongSet entitiesInLevel = new LongOpenHashSet();
+    // Paper - Don't copy
+    private final Long2ObjectLinkedOpenHashMap<ChunkHolder> pendingUnloads;
+    public final LongSet entitiesInLevel;
     public final ServerLevel level;
     private final ThreadedLevelLightEngine lightEngine;
-    private final BlockableEventLoop<Runnable> mainThreadExecutor;
+    public final BlockableEventLoop<Runnable> mainThreadExecutor; // Paper - public
+    final java.util.concurrent.Executor mainInvokingExecutor; // Paper
     public final ChunkGenerator generator;
     public final Supplier<DimensionDataStorage> overworldDataStorage;
     private final PoiManager poiManager;
-    public final LongSet toDrop = new LongOpenHashSet();
+    public final LongSet toDrop;
     private boolean modified;
     private final ChunkTaskPriorityQueueSorter queueSorter;
     private final ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> worldgenMailbox;
     public final ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> mainThreadMailbox;
+    // Paper start
+    final ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> mailboxLight;
+    public void addLightTask(ChunkHolder playerchunk, Runnable run) {
+        this.mailboxLight.tell(ChunkTaskPriorityQueueSorter.message(playerchunk, run));
+    }
+    // Paper end
     public final ChunkProgressListener progressListener;
     private final ChunkStatusUpdateListener chunkStatusListener;
-    public final ChunkMap.DistanceManager distanceManager;
-    private final AtomicInteger tickingGenerated = new AtomicInteger();
+    public final ChunkMap.ChunkDistanceManager distanceManager;
+    private final AtomicInteger tickingGenerated;
     public final StructureManager structureManager;
     private final String storageName;
-    private final PlayerMap playerMap = new PlayerMap();
-    public final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap = new Int2ObjectOpenHashMap<>();
-    private final Long2ByteMap chunkTypeCache = new Long2ByteOpenHashMap();
-    private final Queue<Runnable> unloadQueue = Queues.newConcurrentLinkedQueue();
+    private final PlayerMap playerMap;
+    public final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap;
+    private final Long2ByteMap chunkTypeCache;
+    private final Queue<Runnable> unloadQueue;
     int viewDistance;
+    public final com.destroystokyo.paper.util.PlayerMobDistanceMap playerMobDistanceMap; // Paper
+
+    // CraftBukkit start - recursion-safe executor for Chunk loadCallback() and unloadCallback()
+    public final CallbackExecutor callbackExecutor = new CallbackExecutor();
+    public static final class CallbackExecutor implements java.util.concurrent.Executor, Runnable {
+
+        private Runnable queued; // Paper - revert CB changes
+
+        @Override
+        public void execute(Runnable runnable) {
+            // Paper start - revert CB changes
+            org.spigotmc.AsyncCatcher.catchOp("Callback Executor execute");
+            if (this.queued != null) {
+                MinecraftServer.LOGGER.fatal("Failed to schedule runnable", new IllegalStateException("Already queued"));
+                throw new IllegalStateException("Already queued");
+            }
+            this.queued = runnable;
+            // Paper end - revert CB changes
+        }
+
+        @Override
+        public void run() {
+            // Paper start - revert CB changes
+            org.spigotmc.AsyncCatcher.catchOp("Callback Executor execute");
+            Runnable task = this.queued;
+            if (task != null) {
+                this.queued = null;
+                // Paper end - revert CB changes
+                task.run();
+            }
+        }
+    };
+    // CraftBukkit end
+
+    final CallbackExecutor chunkLoadConversionCallbackExecutor = new CallbackExecutor(); // Paper
+    // Paper start - distance maps
+    private final com.destroystokyo.paper.util.misc.PooledLinkedHashSets<ServerPlayer> pooledLinkedPlayerHashSets = new com.destroystokyo.paper.util.misc.PooledLinkedHashSets<>();
+    public final io.papermc.paper.chunk.PlayerChunkLoader playerChunkManager = new io.papermc.paper.chunk.PlayerChunkLoader(this, this.pooledLinkedPlayerHashSets); // Paper - replace chunk loader
+    // Paper start - use distance map to optimise tracker
+    public static boolean isLegacyTrackingEntity(Entity entity) {
+        return entity.isLegacyTrackingEntity;
+    }
+
+    // inlined EnumMap, TrackingRange.TrackingRangeType
+    static final org.spigotmc.TrackingRange.TrackingRangeType[] TRACKING_RANGE_TYPES = org.spigotmc.TrackingRange.TrackingRangeType.values();
+    public final com.destroystokyo.paper.util.misc.PlayerAreaMap[] playerEntityTrackerTrackMaps;
+    final int[] entityTrackerTrackRanges;
+    public final int getEntityTrackerRange(final int ordinal) {
+        return this.entityTrackerTrackRanges[ordinal];
+    }
+
+    private int convertSpigotRangeToVanilla(final int vanilla) {
+        return MinecraftServer.getServer().getScaledTrackingDistance(vanilla);
+    }
+    // Paper end - use distance map to optimise tracker
+    // Paper start - optimise PlayerChunkMap#isOutsideRange
+    // A note about the naming used here:
+    // Previously, mojang used a "spawn range" of 8 for controlling both ticking and
+    // mob spawn range. However, spigot makes the spawn range configurable by
+    // checking if the chunk is in the tick range (8) and the spawn range
+    // obviously this means a spawn range > 8 cannot be implemented
+
+    // these maps are named after spigot's uses
+    public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerMobSpawnMap; // this map is absent from updateMaps since it's controlled at the start of the chunkproviderserver tick
+    public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerChunkTickRangeMap;
+    // Paper end - optimise PlayerChunkMap#isOutsideRange
+    // Paper start - optimise checkDespawn
+    public static final int GENERAL_AREA_MAP_SQUARE_RADIUS = 40;
+    public static final double GENERAL_AREA_MAP_ACCEPTABLE_SEARCH_RANGE = 16.0 * (GENERAL_AREA_MAP_SQUARE_RADIUS - 1);
+    public static final double GENERAL_AREA_MAP_ACCEPTABLE_SEARCH_RANGE_SQUARED = GENERAL_AREA_MAP_ACCEPTABLE_SEARCH_RANGE * GENERAL_AREA_MAP_ACCEPTABLE_SEARCH_RANGE;
+    public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerGeneralAreaMap;
+    // Paper end - optimise checkDespawn
+
+    void addPlayerToDistanceMaps(ServerPlayer player) {
+        int chunkX = MCUtil.getChunkCoordinate(player.getX());
+        int chunkZ = MCUtil.getChunkCoordinate(player.getZ());
+        // Note: players need to be explicitly added to distance maps before they can be updated
+        // Paper start - use distance map to optimise entity tracker
+        for (int i = 0, len = TRACKING_RANGE_TYPES.length; i < len; ++i) {
+            com.destroystokyo.paper.util.misc.PlayerAreaMap trackMap = this.playerEntityTrackerTrackMaps[i];
+            int trackRange = this.entityTrackerTrackRanges[i];
+
+            trackMap.add(player, chunkX, chunkZ, Math.min(trackRange, player.getBukkitEntity().getViewDistance())); // Paper - per player view distances
+        }
+        // Paper end - use distance map to optimise entity tracker
+        // Paper start - optimise PlayerChunkMap#isOutsideRange
+        this.playerChunkTickRangeMap.update(player, chunkX, chunkZ, DistanceManager.MOB_SPAWN_RANGE);
+        // Paper end - optimise PlayerChunkMap#isOutsideRange
+        // Paper start - optimise PlayerChunkMap#isOutsideRange
+        this.playerChunkTickRangeMap.add(player, chunkX, chunkZ, DistanceManager.MOB_SPAWN_RANGE);
+        // Paper end - optimise PlayerChunkMap#isOutsideRange
+        this.playerChunkManager.addPlayer(player); // Paper - replace chunk loader
+        // Paper start - optimise checkDespawn
+        this.playerGeneralAreaMap.add(player, chunkX, chunkZ, GENERAL_AREA_MAP_SQUARE_RADIUS);
+        // Paper end - optimise checkDespawn
+    }
+
+    void removePlayerFromDistanceMaps(ServerPlayer player) {
+        // Paper start - use distance map to optimise tracker
+        for (int i = 0, len = TRACKING_RANGE_TYPES.length; i < len; ++i) {
+            this.playerEntityTrackerTrackMaps[i].remove(player);
+        }
+        // Paper end - use distance map to optimise tracker
+        // Paper start - optimise PlayerChunkMap#isOutsideRange
+        this.playerMobSpawnMap.remove(player);
+        this.playerChunkTickRangeMap.remove(player);
+        // Paper end - optimise PlayerChunkMap#isOutsideRange
+        this.playerChunkManager.removePlayer(player); // Paper - replace chunk loader
+        // Paper start - optimise checkDespawn
+        this.playerGeneralAreaMap.remove(player);
+        // Paper end - optimise checkDespawn
+    }
+
+    void updateMaps(ServerPlayer player) {
+        int chunkX = MCUtil.getChunkCoordinate(player.getX());
+        int chunkZ = MCUtil.getChunkCoordinate(player.getZ());
+        // Note: players need to be explicitly added to distance maps before they can be updated
+        // Paper start - use distance map to optimise entity tracker
+        for (int i = 0, len = TRACKING_RANGE_TYPES.length; i < len; ++i) {
+            com.destroystokyo.paper.util.misc.PlayerAreaMap trackMap = this.playerEntityTrackerTrackMaps[i];
+            int trackRange = this.entityTrackerTrackRanges[i];
+
+            trackMap.update(player, chunkX, chunkZ, Math.min(trackRange, player.getBukkitEntity().getViewDistance())); // Paper - per player view distances
+        }
+        // Paper end - use distance map to optimise entity tracker
+        // Paper start - optimise PlayerChunkMap#isOutsideRange
+        this.playerChunkTickRangeMap.update(player, chunkX, chunkZ, DistanceManager.MOB_SPAWN_RANGE);
+        // Paper end - optimise PlayerChunkMap#isOutsideRange
+        this.playerChunkManager.updatePlayer(player); // Paper - replace chunk loader
+        // Paper start - optimise checkDespawn
+        this.playerGeneralAreaMap.update(player, chunkX, chunkZ, GENERAL_AREA_MAP_SQUARE_RADIUS);
+        // Paper end - optimise checkDespawn
+    }
+    // Paper end
+    // Paper start
+    public final List<io.papermc.paper.chunk.SingleThreadChunkRegionManager> regionManagers = new java.util.ArrayList<>();
+    public final io.papermc.paper.chunk.SingleThreadChunkRegionManager dataRegionManager;
+
+    public static final class DataRegionData implements io.papermc.paper.chunk.SingleThreadChunkRegionManager.RegionData {
+        // Paper start - optimise notify()
+        private io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<Mob> navigators;
+
+        public io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<Mob> getNavigators() {
+            return this.navigators;
+        }
+
+        public boolean addToNavigators(final Mob navigator) {
+            if (this.navigators == null) {
+                this.navigators = new io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<>();
+            }
+            return this.navigators.add(navigator);
+        }
+
+        public boolean removeFromNavigators(final Mob navigator) {
+            if (this.navigators == null) {
+                return false;
+            }
+            return this.navigators.remove(navigator);
+        }
+        // Paper end - optimise notify()
+    }
+
+    public static final class DataRegionSectionData implements io.papermc.paper.chunk.SingleThreadChunkRegionManager.RegionSectionData {
+
+        // Paper start - optimise notify()
+        private io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<Mob> navigators;
+
+        public io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<Mob> getNavigators() {
+            return this.navigators;
+        }
+
+        public boolean addToNavigators(final io.papermc.paper.chunk.SingleThreadChunkRegionManager.RegionSection section, final Mob navigator) {
+            if (this.navigators == null) {
+                this.navigators = new io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<>();
+            }
+            final boolean ret = this.navigators.add(navigator);
+            if (ret) {
+                final DataRegionData data = (DataRegionData)section.getRegion().regionData;
+                if (!data.addToNavigators(navigator)) {
+                    throw new IllegalStateException();
+                }
+            }
+            return ret;
+        }
+
+        public boolean removeFromNavigators(final io.papermc.paper.chunk.SingleThreadChunkRegionManager.RegionSection section, final Mob navigator) {
+            if (this.navigators == null) {
+                return false;
+            }
+            final boolean ret = this.navigators.remove(navigator);
+            if (ret) {
+                final DataRegionData data = (DataRegionData)section.getRegion().regionData;
+                if (!data.removeFromNavigators(navigator)) {
+                    throw new IllegalStateException();
+                }
+            }
+            return ret;
+        }
+        // Paper end - optimise notify()
+
+        @Override
+        public void removeFromRegion(final io.papermc.paper.chunk.SingleThreadChunkRegionManager.RegionSection section,
+                                     final io.papermc.paper.chunk.SingleThreadChunkRegionManager.Region from) {
+            final DataRegionSectionData sectionData = (DataRegionSectionData)section.sectionData;
+            final DataRegionData fromData = (DataRegionData)from.regionData;
+            // Paper start - optimise notify()
+            if (sectionData.navigators != null) {
+                for (final Iterator<Mob> iterator = sectionData.navigators.unsafeIterator(io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS); iterator.hasNext();) {
+                    if (!fromData.removeFromNavigators(iterator.next())) {
+                        throw new IllegalStateException();
+                    }
+                }
+            }
+            // Paper end - optimise notify()
+        }
+
+        @Override
+        public void addToRegion(final io.papermc.paper.chunk.SingleThreadChunkRegionManager.RegionSection section,
+                                final io.papermc.paper.chunk.SingleThreadChunkRegionManager.Region oldRegion,
+                                final io.papermc.paper.chunk.SingleThreadChunkRegionManager.Region newRegion) {
+            final DataRegionSectionData sectionData = (DataRegionSectionData)section.sectionData;
+            final DataRegionData oldRegionData = oldRegion == null ? null : (DataRegionData)oldRegion.regionData;
+            final DataRegionData newRegionData = (DataRegionData)newRegion.regionData;
+            // Paper start - optimise notify()
+            if (sectionData.navigators != null) {
+                for (final Iterator<Mob> iterator = sectionData.navigators.unsafeIterator(io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS); iterator.hasNext();) {
+                    if (!newRegionData.addToNavigators(iterator.next())) {
+                        throw new IllegalStateException();
+                    }
+                }
+            }
+            // Paper end - optimise notify()
+        }
+    }
 
+    public final ChunkHolder getUnloadingChunkHolder(int chunkX, int chunkZ) {
+        return this.pendingUnloads.get(io.papermc.paper.util.CoordinateUtils.getChunkKey(chunkX, chunkZ));
+    }
+    // Paper end
+
+    boolean unloadingPlayerChunk = false; // Paper - do not allow ticket level changes while unloading chunks
     public ChunkMap(ServerLevel world, LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, StructureManager structureManager, Executor executor, BlockableEventLoop<Runnable> mainThreadExecutor, LightChunkGetter chunkProvider, ChunkGenerator chunkGenerator, ChunkProgressListener worldGenerationProgressListener, ChunkStatusUpdateListener chunkStatusChangeListener, Supplier<DimensionDataStorage> persistentStateManagerFactory, int viewDistance, boolean dsync) {
         super(new File(session.getDimensionPath(world.dimension()), "region"), dataFixer, dsync);
+        // Paper - don't copy
+        this.pendingUnloads = new Long2ObjectLinkedOpenHashMap();
+        this.entitiesInLevel = new LongOpenHashSet();
+        this.toDrop = new LongOpenHashSet();
+        this.tickingGenerated = new AtomicInteger();
+        this.playerMap = new PlayerMap();
+        this.entityMap = new Int2ObjectOpenHashMap();
+        this.chunkTypeCache = new Long2ByteOpenHashMap();
+        this.unloadQueue = new com.destroystokyo.paper.utils.CachedSizeConcurrentLinkedQueue<>(); // Paper - need constant-time size()
         this.structureManager = structureManager;
         File file = session.getDimensionPath(world.dimension());
+
         this.storageName = file.getName();
         this.level = world;
         this.generator = chunkGenerator;
         this.mainThreadExecutor = mainThreadExecutor;
-        ProcessorMailbox<Runnable> processorMailbox = ProcessorMailbox.create(executor, "worldgen");
-        ProcessorHandle<Runnable> processorHandle = ProcessorHandle.of("main", mainThreadExecutor::tell);
+        // Paper start
+        this.mainInvokingExecutor = (run) -> {
+            if (MCUtil.isMainThread()) {
+                run.run();
+            } else {
+                mainThreadExecutor.execute(run);
+            }
+        };
+        // Paper end
+        ProcessorMailbox<Runnable> threadedmailbox = ProcessorMailbox.create(executor, "worldgen");
+
+        Objects.requireNonNull(mainThreadExecutor);
+        ProcessorHandle<Runnable> mailbox = ProcessorHandle.of("main", mainThreadExecutor::tell);
+
         this.progressListener = worldGenerationProgressListener;
         this.chunkStatusListener = chunkStatusChangeListener;
-        ProcessorMailbox<Runnable> processorMailbox2 = ProcessorMailbox.create(executor, "light");
-        this.queueSorter = new ChunkTaskPriorityQueueSorter(ImmutableList.of(processorMailbox, processorHandle, processorMailbox2), executor, Integer.MAX_VALUE);
-        this.worldgenMailbox = this.queueSorter.getProcessor(processorMailbox, false);
-        this.mainThreadMailbox = this.queueSorter.getProcessor(processorHandle, false);
-        this.lightEngine = new ThreadedLevelLightEngine(chunkProvider, this, this.level.dimensionType().hasSkyLight(), processorMailbox2, this.queueSorter.getProcessor(processorMailbox2, false));
-        this.distanceManager = new ChunkMap.DistanceManager(executor, mainThreadExecutor);
+        ProcessorMailbox<Runnable> lightthreaded; ProcessorMailbox<Runnable> threadedmailbox1 = lightthreaded = ProcessorMailbox.create(executor, "light"); // Paper
+
+        this.queueSorter = new ChunkTaskPriorityQueueSorter(ImmutableList.of(threadedmailbox, mailbox, threadedmailbox1), executor, Integer.MAX_VALUE);
+        this.worldgenMailbox = this.queueSorter.getProcessor(threadedmailbox, false);
+        this.mainThreadMailbox = this.queueSorter.getProcessor(mailbox, false);
+        this.mailboxLight = this.queueSorter.getProcessor(lightthreaded, false);// Paper
+        this.lightEngine = new ThreadedLevelLightEngine(chunkProvider, this, this.level.dimensionType().hasSkyLight(), threadedmailbox1, this.queueSorter.getProcessor(threadedmailbox1, false));
+        this.distanceManager = new ChunkMap.ChunkDistanceManager(executor, mainThreadExecutor); this.distanceManager.chunkMap = this; // Paper
         this.overworldDataStorage = persistentStateManagerFactory;
         this.poiManager = new PoiManager(new File(file, "poi"), dataFixer, dsync, world);
         this.setViewDistance(viewDistance);
+        // Paper start
+        this.dataRegionManager = new io.papermc.paper.chunk.SingleThreadChunkRegionManager(this.level, 2, (1.0 / 3.0), 1, 6, "Data", DataRegionData::new, DataRegionSectionData::new);
+        this.regionManagers.add(this.dataRegionManager);
+        // Paper end
+        // Paper start - no-tick view distance
+        this.setNoTickViewDistance(this.level.paperConfig.noTickViewDistance); // Paper - replace chunk loading system
+        // Paper end - no-tick view distance
+        this.playerMobDistanceMap = this.level.paperConfig.perPlayerMobSpawns ? new com.destroystokyo.paper.util.PlayerMobDistanceMap() : null; // Paper
+        // Paper start - use distance map to optimise entity tracker
+        this.playerEntityTrackerTrackMaps = new com.destroystokyo.paper.util.misc.PlayerAreaMap[TRACKING_RANGE_TYPES.length];
+        this.entityTrackerTrackRanges = new int[TRACKING_RANGE_TYPES.length];
+
+        org.spigotmc.SpigotWorldConfig spigotWorldConfig = this.level.spigotConfig;
+
+        for (int ordinal = 0, len = TRACKING_RANGE_TYPES.length; ordinal < len; ++ordinal) {
+            org.spigotmc.TrackingRange.TrackingRangeType trackingRangeType = TRACKING_RANGE_TYPES[ordinal];
+            int configuredSpigotValue;
+            switch (trackingRangeType) {
+                case PLAYER:
+                    configuredSpigotValue = spigotWorldConfig.playerTrackingRange;
+                    break;
+                case ANIMAL:
+                    configuredSpigotValue = spigotWorldConfig.animalTrackingRange;
+                    break;
+                case MONSTER:
+                    configuredSpigotValue = spigotWorldConfig.monsterTrackingRange;
+                    break;
+                case MISC:
+                    configuredSpigotValue = spigotWorldConfig.miscTrackingRange;
+                    break;
+                case OTHER:
+                    configuredSpigotValue = spigotWorldConfig.otherTrackingRange;
+                    break;
+                case ENDERDRAGON:
+                    configuredSpigotValue = EntityType.ENDER_DRAGON.clientTrackingRange() * 16;
+                    break;
+                default:
+                    throw new IllegalStateException("Missing case for enum " + trackingRangeType);
+            }
+            configuredSpigotValue = convertSpigotRangeToVanilla(configuredSpigotValue);
+
+            int trackRange = (configuredSpigotValue >>> 4) + ((configuredSpigotValue & 15) != 0 ? 1 : 0);
+            this.entityTrackerTrackRanges[ordinal] = trackRange;
+
+            this.playerEntityTrackerTrackMaps[ordinal] = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets);
+        }
+        // Paper end - use distance map to optimise entity tracker
+        // Paper start - optimise PlayerChunkMap#isOutsideRange
+        this.playerChunkTickRangeMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets,
+            (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+             com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newState) -> {
+                ChunkHolder playerChunk = ChunkMap.this.getUpdatingChunkIfPresent(MCUtil.getCoordinateKey(rangeX, rangeZ));
+                if (playerChunk != null) {
+                    playerChunk.playersInChunkTickRange = newState;
+                }
+            },
+            (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+             com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newState) -> {
+                ChunkHolder playerChunk = ChunkMap.this.getUpdatingChunkIfPresent(MCUtil.getCoordinateKey(rangeX, rangeZ));
+                if (playerChunk != null) {
+                    playerChunk.playersInChunkTickRange = newState;
+                }
+            });
+        this.playerMobSpawnMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets,
+            (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+             com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newState) -> {
+                ChunkHolder playerChunk = ChunkMap.this.getUpdatingChunkIfPresent(MCUtil.getCoordinateKey(rangeX, rangeZ));
+                if (playerChunk != null) {
+                    playerChunk.playersInMobSpawnRange = newState;
+                }
+            },
+            (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+             com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newState) -> {
+                ChunkHolder playerChunk = ChunkMap.this.getUpdatingChunkIfPresent(MCUtil.getCoordinateKey(rangeX, rangeZ));
+                if (playerChunk != null) {
+                    playerChunk.playersInMobSpawnRange = newState;
+                }
+            });
+        // Paper end - optimise PlayerChunkMap#isOutsideRange
+        // Paper start - optimise checkDespawn
+        this.playerGeneralAreaMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets,
+            (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+             com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newState) -> {
+                LevelChunk chunk = ChunkMap.this.level.getChunkSource().getChunkAtIfCachedImmediately(rangeX, rangeZ);
+                if (chunk != null) {
+                    chunk.updateGeneralAreaCache(newState);
+                }
+            },
+            (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+             com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newState) -> {
+                LevelChunk chunk = ChunkMap.this.level.getChunkSource().getChunkAtIfCachedImmediately(rangeX, rangeZ);
+                if (chunk != null) {
+                    chunk.updateGeneralAreaCache(newState);
+                }
+            });
+        // Paper end - optimise checkDespawn
+    }
+
+    // Paper start - Chunk Prioritization
+    public void queueHolderUpdate(ChunkHolder playerchunk) {
+        Runnable runnable = () -> {
+            if (isUnloading(playerchunk)) {
+                return; // unloaded
+            }
+            distanceManager.pendingChunkUpdates.add(playerchunk);
+            if (!distanceManager.pollingPendingChunkUpdates) {
+                level.getChunkSource().runDistanceManagerUpdates();
+            }
+        };
+        if (MCUtil.isMainThread()) {
+            // We can't use executor here because it will not execute tasks if its currently in the middle of executing tasks...
+            runnable.run();
+        } else {
+            mainThreadExecutor.execute(runnable);
+        }
+    }
+
+    private boolean isUnloading(ChunkHolder playerchunk) {
+        return playerchunk == null || toDrop.contains(playerchunk.pos.toLong());
+    }
+
+    private void updateChunkPriorityMap(it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap map, long chunk, int level) {
+        int prev = map.getOrDefault(chunk, -1);
+        if (level > prev) {
+            map.put(chunk, level);
+        }
+    }
+
+    public void checkHighPriorityChunks(ServerPlayer player) {
+        if (true) return; // Paper - replace player chunk loader
+        int currentTick = MinecraftServer.currentTick;
+        if (currentTick - player.lastHighPriorityChecked < 20 || !player.isRealPlayer) { // weed out fake players
+            return;
+        }
+        player.lastHighPriorityChecked = currentTick;
+        it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap priorities = new it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap();
+
+        int viewDistance = 10;//int viewDistance = getEffectiveNoTickViewDistance(); // Paper - replace player chunk loader
+        net.minecraft.core.BlockPos.MutableBlockPos pos = new net.minecraft.core.BlockPos.MutableBlockPos();
+
+        // Prioritize circular near
+        double playerChunkX = Mth.floor(player.getX()) >> 4;
+        double playerChunkZ = Mth.floor(player.getZ()) >> 4;
+        pos.set(player.getX(), 0, player.getZ());
+        double twoThirdModifier = 2D / 3D;
+        MCUtil.getSpiralOutChunks(pos, Math.min(6, viewDistance)).forEach(coord -> {
+            if (shouldSkipPrioritization(coord)) return;
+
+            double dist = MCUtil.distance(playerChunkX, 0, playerChunkZ, coord.x, 0, coord.z);
+            // Prioritize immediate
+            if (dist <= 4) {
+                updateChunkPriorityMap(priorities, coord.toLong(), (int) (27 - dist));
+                return;
+            }
+
+            // Prioritize nearby chunks
+            updateChunkPriorityMap(priorities, coord.toLong(), (int) (20 - dist * twoThirdModifier));
+        });
+
+        // Prioritize Frustum near 3
+        ChunkPos front3 = player.getChunkInFront(3);
+        pos.set(front3.x << 4, 0, front3.z << 4);
+        MCUtil.getSpiralOutChunks(pos, Math.min(5, viewDistance)).forEach(coord -> {
+            if (shouldSkipPrioritization(coord)) return;
+
+            double dist = MCUtil.distance(playerChunkX, 0, playerChunkZ, coord.x, 0, coord.z);
+            updateChunkPriorityMap(priorities, coord.toLong(), (int) (25 - dist * twoThirdModifier));
+        });
+
+        // Prioritize Frustum near 5
+        if (viewDistance > 4) {
+            ChunkPos front5 = player.getChunkInFront(5);
+            pos.set(front5.x << 4, 0, front5.z << 4);
+            MCUtil.getSpiralOutChunks(pos, 4).forEach(coord -> {
+                if (shouldSkipPrioritization(coord)) return;
+
+                double dist = MCUtil.distance(playerChunkX, 0, playerChunkZ, coord.x, 0, coord.z);
+                updateChunkPriorityMap(priorities, coord.toLong(), (int) (25 - dist * twoThirdModifier));
+            });
+        }
+
+        // Prioritize Frustum far 7
+        if (viewDistance > 6) {
+            ChunkPos front7 = player.getChunkInFront(7);
+            pos.set(front7.x << 4, 0, front7.z << 4);
+            MCUtil.getSpiralOutChunks(pos, 3).forEach(coord -> {
+                if (shouldSkipPrioritization(coord)) {
+                    return;
+                }
+                double dist = MCUtil.distance(playerChunkX, 0, playerChunkZ, coord.x, 0, coord.z);
+                updateChunkPriorityMap(priorities, coord.toLong(), (int) (25 - dist * twoThirdModifier));
+            });
+        }
+
+        if (priorities.isEmpty()) return;
+        distanceManager.delayDistanceManagerTick = true;
+        priorities.long2IntEntrySet().fastForEach(entry -> distanceManager.markHighPriority(new ChunkPos(entry.getLongKey()), entry.getIntValue()));
+        distanceManager.delayDistanceManagerTick = false;
+        level.getChunkSource().runDistanceManagerUpdates();
+
+    }
+
+    private boolean shouldSkipPrioritization(ChunkPos coord) {
+        if (true) return true; // Paper - replace player chunk loader - unused outside paper player loader logic
+        ChunkHolder chunk = getUpdatingChunkIfPresent(coord.toLong());
+        return chunk != null && (chunk.isFullChunkReady());
     }
+    // Paper end
+
+    // Paper start
+    public void updatePlayerMobTypeMap(Entity entity) {
+        if (!this.level.paperConfig.perPlayerMobSpawns) {
+            return;
+        }
+        int chunkX = (int)Math.floor(entity.getX()) >> 4;
+        int chunkZ = (int)Math.floor(entity.getZ()) >> 4;
+        int index = entity.getType().getCategory().ordinal();
+
+        for (ServerPlayer player : this.playerMobDistanceMap.getPlayersInRange(chunkX, chunkZ)) {
+            ++player.mobCounts[index];
+        }
+    }
+
+    public int getMobCountNear(ServerPlayer entityPlayer, net.minecraft.world.entity.MobCategory mobCategory) {
+        return entityPlayer.mobCounts[mobCategory.ordinal()];
+    }
+    // Paper end
 
     private static double euclideanDistanceSquared(ChunkPos pos, Entity entity) {
-        double d = (double)SectionPos.sectionToBlockCoord(pos.x, 8);
-        double e = (double)SectionPos.sectionToBlockCoord(pos.z, 8);
-        double f = d - entity.getX();
-        double g = e - entity.getZ();
-        return f * f + g * g;
+        double d0 = (double) SectionPos.sectionToBlockCoord(pos.x, 8);
+        double d1 = (double) SectionPos.sectionToBlockCoord(pos.z, 8);
+        double d2 = d0 - entity.getX();
+        double d3 = d1 - entity.getZ();
+
+        return d2 * d2 + d3 * d3;
     }
 
     private static int checkerboardDistance(ChunkPos pos, ServerPlayer player, boolean useWatchedPosition) {
         int i;
         int j;
+
         if (useWatchedPosition) {
-            SectionPos sectionPos = player.getLastSectionPos();
-            i = sectionPos.x();
-            j = sectionPos.z();
+            SectionPos sectionposition = player.getLastSectionPos();
+
+            i = sectionposition.x();
+            j = sectionposition.z();
         } else {
             i = SectionPos.blockToSectionCoord(player.getBlockX());
             j = SectionPos.blockToSectionCoord(player.getBlockZ());
         }
 
-        return checkerboardDistance(pos, i, j);
+        return ChunkMap.checkerboardDistance(pos, i, j);
     }
 
     private static int checkerboardDistance(ChunkPos chunkPos, Entity entity) {
-        return checkerboardDistance(chunkPos, SectionPos.blockToSectionCoord(entity.getBlockX()), SectionPos.blockToSectionCoord(entity.getBlockZ()));
+        return ChunkMap.checkerboardDistance(chunkPos, SectionPos.blockToSectionCoord(entity.getBlockX()), SectionPos.blockToSectionCoord(entity.getBlockZ()));
     }
 
     private static int checkerboardDistance(ChunkPos pos, int x, int z) {
-        int i = pos.x - x;
-        int j = pos.z - z;
-        return Math.max(Math.abs(i), Math.abs(j));
+        int k = pos.x - x;
+        int l = pos.z - z;
+
+        return Math.max(Math.abs(k), Math.abs(l));
     }
 
     protected ThreadedLevelLightEngine getLightEngine() {
@@ -184,88 +708,120 @@
 
     @Nullable
     public ChunkHolder getUpdatingChunkIfPresent(long pos) {
-        return this.updatingChunkMap.get(pos);
+        return this.updatingChunks.getUpdating(pos); // Paper - Don't copy
     }
 
     @Nullable
     public ChunkHolder getVisibleChunkIfPresent(long pos) {
-        return this.visibleChunkMap.get(pos);
+        // Paper start - Don't copy
+        if (Thread.currentThread() == this.level.thread) {
+            return this.updatingChunks.getVisible(pos);
+        }
+        return this.updatingChunks.getVisibleAsync(pos);
+        // Paper end - Don't copy
     }
 
     protected IntSupplier getChunkQueueLevel(long pos) {
         return () -> {
-            ChunkHolder chunkHolder = this.getVisibleChunkIfPresent(pos);
-            return chunkHolder == null ? ChunkTaskPriorityQueue.PRIORITY_LEVEL_COUNT - 1 : Math.min(chunkHolder.getQueueLevel(), ChunkTaskPriorityQueue.PRIORITY_LEVEL_COUNT - 1);
+            ChunkHolder playerchunk = this.getVisibleChunkIfPresent(pos);
+
+            return playerchunk == null ? ChunkTaskPriorityQueue.PRIORITY_LEVEL_COUNT - 1 : Math.min(playerchunk.getQueueLevel(), ChunkTaskPriorityQueue.PRIORITY_LEVEL_COUNT - 1);
         };
     }
 
     public String getChunkDebugData(ChunkPos chunkPos) {
-        ChunkHolder chunkHolder = this.getVisibleChunkIfPresent(chunkPos.toLong());
-        if (chunkHolder == null) {
+        ChunkHolder playerchunk = this.getVisibleChunkIfPresent(chunkPos.toLong());
+
+        if (playerchunk == null) {
             return "null";
         } else {
-            String string = chunkHolder.getTicketLevel() + "\n";
-            ChunkStatus chunkStatus = chunkHolder.getLastAvailableStatus();
-            ChunkAccess chunkAccess = chunkHolder.getLastAvailable();
-            if (chunkStatus != null) {
-                string = string + "St: \u00a7" + chunkStatus.getIndex() + chunkStatus + "\u00a7r\n";
+            String s = playerchunk.getTicketLevel() + "\n";
+            ChunkStatus chunkstatus = playerchunk.getLastAvailableStatus();
+            ChunkAccess ichunkaccess = playerchunk.getLastAvailable();
+
+            if (chunkstatus != null) {
+                s = s + "St: \u00a7" + chunkstatus.getIndex() + chunkstatus + "\u00a7r\n";
             }
 
-            if (chunkAccess != null) {
-                string = string + "Ch: \u00a7" + chunkAccess.getStatus().getIndex() + chunkAccess.getStatus() + "\u00a7r\n";
+            if (ichunkaccess != null) {
+                s = s + "Ch: \u00a7" + ichunkaccess.getStatus().getIndex() + ichunkaccess.getStatus() + "\u00a7r\n";
             }
 
-            ChunkHolder.FullChunkStatus fullChunkStatus = chunkHolder.getFullStatus();
-            string = string + "\u00a7" + fullChunkStatus.ordinal() + fullChunkStatus;
-            return string + "\u00a7r";
+            ChunkHolder.FullChunkStatus playerchunk_state = playerchunk.getFullStatus();
+
+            s = s + "\u00a7" + playerchunk_state.ordinal() + playerchunk_state;
+            return s + "\u00a7r";
         }
     }
 
+    // Paper start
+    public final int getEffectiveViewDistance() {
+        // TODO this needs to be checked on update
+        // Mojang currently sets it to +1 of the configured view distance. So subtract one to get the one we really want.
+        return this.viewDistance - 1;
+    }
+    // Paper end
+
     private CompletableFuture<Either<List<ChunkAccess>, ChunkHolder.ChunkLoadingFailure>> getChunkRangeFuture(ChunkPos centerChunk, int margin, IntFunction<ChunkStatus> distanceToStatus) {
         List<CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> list = Lists.newArrayList();
-        int i = centerChunk.x;
-        int j = centerChunk.z;
+        int j = centerChunk.x;
+        int k = centerChunk.z;
+        ChunkHolder requestingNeighbor = getUpdatingChunkIfPresent(centerChunk.toLong()); // Paper
 
-        for(int k = -margin; k <= margin; ++k) {
-            for(int l = -margin; l <= margin; ++l) {
-                int m = Math.max(Math.abs(l), Math.abs(k));
-                final ChunkPos chunkPos = new ChunkPos(i + l, j + k);
-                long n = chunkPos.toLong();
-                ChunkHolder chunkHolder = this.getUpdatingChunkIfPresent(n);
-                if (chunkHolder == null) {
+        for (int l = -margin; l <= margin; ++l) {
+            for (int i1 = -margin; i1 <= margin; ++i1) {
+                int j1 = Math.max(Math.abs(i1), Math.abs(l));
+                final ChunkPos chunkcoordintpair1 = new ChunkPos(j + i1, k + l);
+                long k1 = chunkcoordintpair1.toLong();
+                ChunkHolder playerchunk = this.getUpdatingChunkIfPresent(k1);
+
+                if (playerchunk == null) {
                     return CompletableFuture.completedFuture(Either.right(new ChunkHolder.ChunkLoadingFailure() {
-                        @Override
                         public String toString() {
-                            return "Unloaded " + chunkPos;
+                            return "Unloaded " + chunkcoordintpair1;
                         }
                     }));
                 }
 
-                ChunkStatus chunkStatus = distanceToStatus.apply(m);
-                CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completableFuture = chunkHolder.getOrScheduleFuture(chunkStatus, this);
-                list.add(completableFuture);
+                ChunkStatus chunkstatus = (ChunkStatus) distanceToStatus.apply(j1);
+                CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = playerchunk.getOrScheduleFuture(chunkstatus, this);
+                // Paper start
+                if (requestingNeighbor != null && requestingNeighbor != playerchunk && !completablefuture.isDone()) {
+                    requestingNeighbor.onNeighborRequest(playerchunk, chunkstatus);
+                    completablefuture.thenAccept(either -> {
+                        requestingNeighbor.onNeighborDone(playerchunk, chunkstatus, either.left().orElse(null));
+                    });
+                }
+                // Paper end
+
+                list.add(completablefuture);
             }
         }
 
-        CompletableFuture<List<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> completableFuture2 = Util.sequence(list);
-        return completableFuture2.thenApply((listx) -> {
+        CompletableFuture<List<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> completablefuture1 = Util.sequence((List) list);
+
+        return completablefuture1.thenApply((list1) -> {
             List<ChunkAccess> list2 = Lists.newArrayList();
-            int l = 0;
+            // CraftBukkit start - decompile error
+            int cnt = 0;
 
-            for(final Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either : listx) {
+            for (Iterator iterator = list1.iterator(); iterator.hasNext(); ++cnt) {
+                final int l1 = cnt;
+                // CraftBukkit end
+                final Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either = (Either) iterator.next();
                 Optional<ChunkAccess> optional = either.left();
+
                 if (!optional.isPresent()) {
-                    final int m = l;
                     return Either.right(new ChunkHolder.ChunkLoadingFailure() {
-                        @Override
                         public String toString() {
-                            return "Unloaded " + new ChunkPos(i + m % (margin * 2 + 1), j + m / (margin * 2 + 1)) + " " + either.right().get();
+                            ChunkPos chunkcoordintpair2 = new ChunkPos(j + l1 % (margin * 2 + 1), k + l1 / (margin * 2 + 1));
+
+                            return "Unloaded " + chunkcoordintpair2 + " " + either.right().get();
                         }
                     });
                 }
 
-                list2.add(optional.get());
-                ++l;
+                list2.add((ChunkAccess) optional.get());
             }
 
             return Either.left(list2);
@@ -277,37 +833,45 @@
             return ChunkStatus.FULL;
         }).thenApplyAsync((either) -> {
             return either.mapLeft((list) -> {
-                return (LevelChunk)list.get(list.size() / 2);
+                return (LevelChunk) list.get(list.size() / 2);
             });
-        }, this.mainThreadExecutor);
+        }, this.mainInvokingExecutor); // Paper
     }
 
     @Nullable
-    ChunkHolder updateChunkScheduling(long pos, int level, @Nullable ChunkHolder holder, int i) {
-        if (i > MAX_CHUNK_DISTANCE && level > MAX_CHUNK_DISTANCE) {
+    ChunkHolder updateChunkScheduling(long pos, int level, @Nullable ChunkHolder holder, int k) {
+        if (this.unloadingPlayerChunk) { net.minecraft.server.MinecraftServer.LOGGER.fatal("Cannot tick distance manager while unloading playerchunks", new Throwable()); throw new IllegalStateException("Cannot tick distance manager while unloading playerchunks"); } // Paper
+        if (k > ChunkMap.MAX_CHUNK_DISTANCE && level > ChunkMap.MAX_CHUNK_DISTANCE) {
             return holder;
         } else {
             if (holder != null) {
                 holder.setTicketLevel(level);
+                // Paper - move to correct place
             }
 
             if (holder != null) {
-                if (level > MAX_CHUNK_DISTANCE) {
+                if (level > ChunkMap.MAX_CHUNK_DISTANCE) {
                     this.toDrop.add(pos);
                 } else {
                     this.toDrop.remove(pos);
                 }
             }
 
-            if (level <= MAX_CHUNK_DISTANCE && holder == null) {
-                holder = this.pendingUnloads.remove(pos);
+            if (level <= ChunkMap.MAX_CHUNK_DISTANCE && holder == null) {
+                holder = (ChunkHolder) this.pendingUnloads.remove(pos);
                 if (holder != null) {
                     holder.setTicketLevel(level);
+                    holder.updateRanges(); // Paper - optimise isOutsideOfRange // Paper - move to correct place
                 } else {
                     holder = new ChunkHolder(new ChunkPos(pos), level, this.level, this.lightEngine, this.queueSorter, this);
+                    // Paper start
+                    for (int index = 0, len = this.regionManagers.size(); index < len; ++index) {
+                        this.regionManagers.get(index).addChunk(holder.pos.x, holder.pos.z);
+                    }
+                    // Paper end
                 }
 
-                this.updatingChunkMap.put(pos, holder);
+                this.updatingChunks.queueUpdate(pos, holder); // Paper - Don't copy
                 this.modified = true;
             }
 
@@ -319,6 +883,7 @@
     public void close() throws IOException {
         try {
             this.queueSorter.close();
+            this.level.asyncChunkTaskManager.close(true); // Paper - Required since we're closing regionfiles in the next line
             this.poiManager.close();
         } finally {
             super.close();
@@ -326,38 +891,114 @@
 
     }
 
+    // Paper start - incremental autosave
+    final ObjectRBTreeSet<ChunkHolder> autoSaveQueue = new ObjectRBTreeSet<>((playerchunk1, playerchunk2) -> {
+        int timeCompare =  Long.compare(playerchunk1.lastAutoSaveTime, playerchunk2.lastAutoSaveTime);
+        if (timeCompare != 0) {
+            return timeCompare;
+        }
+
+        return Long.compare(MCUtil.getCoordinateKey(playerchunk1.pos), MCUtil.getCoordinateKey(playerchunk2.pos));
+    });
+
+    protected void saveIncrementally() {
+        int savedThisTick = 0;
+        // optimized since we search far less chunks to hit ones that need to be saved
+        List<ChunkHolder> reschedule = new java.util.ArrayList<>(this.level.paperConfig.maxAutoSaveChunksPerTick);
+        long currentTick = this.level.getGameTime();
+        long maxSaveTime = currentTick - this.level.paperConfig.autoSavePeriod;
+
+        for (Iterator<ChunkHolder> iterator = this.autoSaveQueue.iterator(); iterator.hasNext();) {
+            ChunkHolder playerchunk = iterator.next();
+            if (playerchunk.lastAutoSaveTime > maxSaveTime) {
+                break;
+            }
+
+            iterator.remove();
+
+            ChunkAccess ichunkaccess = playerchunk.getChunkToSave().getNow(null);
+            if (ichunkaccess instanceof LevelChunk) {
+                boolean shouldSave = ((LevelChunk)ichunkaccess).lastSaveTime <= maxSaveTime;
+
+                if (shouldSave && this.save(ichunkaccess) && this.level.entityManager.storeChunkSections(playerchunk.pos.toLong(), entity -> {})) {
+                    ++savedThisTick;
+
+                    if (!playerchunk.setHasBeenLoaded()) {
+                        // do not fall through to reschedule logic
+                        playerchunk.inactiveTimeStart = currentTick;
+                        if (savedThisTick >= this.level.paperConfig.maxAutoSaveChunksPerTick) {
+                            break;
+                        }
+                        continue;
+                    }
+                }
+            }
+
+            reschedule.add(playerchunk);
+
+            if (savedThisTick >= this.level.paperConfig.maxAutoSaveChunksPerTick) {
+                break;
+            }
+        }
+
+        for (int i = 0, len = reschedule.size(); i < len; ++i) {
+            ChunkHolder playerchunk = reschedule.get(i);
+            playerchunk.lastAutoSaveTime = this.level.getGameTime();
+            this.autoSaveQueue.add(playerchunk);
+        }
+    }
+    // Paper end
+
     protected void saveAllChunks(boolean flush) {
+        // Paper start - do not overload I/O threads with too much work when saving
+        int[] saved = new int[1];
+        int maxAsyncSaves = 50;
+        Runnable onChunkSave = () -> {
+            if (++saved[0] >= maxAsyncSaves) {
+                saved[0] = 0;
+                com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.flush();
+            }
+        };
+        // Paper end - do not overload I/O threads with too much work when saving
         if (flush) {
-            List<ChunkHolder> list = this.visibleChunkMap.values().stream().filter(ChunkHolder::wasAccessibleSinceLastSave).peek(ChunkHolder::refreshAccessibility).collect(Collectors.toList());
-            MutableBoolean mutableBoolean = new MutableBoolean();
+            List<ChunkHolder> list = (List) this.updatingChunks.getVisibleValuesCopy().stream().filter(ChunkHolder::wasAccessibleSinceLastSave).peek(ChunkHolder::refreshAccessibility).collect(Collectors.toList()); // Paper
+            MutableBoolean mutableboolean = new MutableBoolean();
 
             do {
-                mutableBoolean.setFalse();
-                list.stream().map((chunkHolder) -> {
-                    CompletableFuture<ChunkAccess> completableFuture;
+                boolean isShuttingDown = level.getServer().hasStopped(); // Paper
+                mutableboolean.setFalse();
+                list.stream().map((playerchunk) -> {
+                    CompletableFuture completablefuture;
+
                     do {
-                        completableFuture = chunkHolder.getChunkToSave();
-                        this.mainThreadExecutor.managedBlock(completableFuture::isDone);
-                    } while(completableFuture != chunkHolder.getChunkToSave());
+                        completablefuture = playerchunk.getChunkToSave();
+                        BlockableEventLoop iasynctaskhandler = this.mainThreadExecutor;
 
-                    return completableFuture.join();
-                }).filter((chunkAccess) -> {
-                    return chunkAccess instanceof ImposterProtoChunk || chunkAccess instanceof LevelChunk;
-                }).filter(this::save).forEach((chunkAccess) -> {
-                    mutableBoolean.setTrue();
+                        Objects.requireNonNull(completablefuture);
+                        iasynctaskhandler.managedBlock(completablefuture::isDone);
+                    } while (completablefuture != playerchunk.getChunkToSave());
+
+                    return (ChunkAccess) completablefuture.join();
+                }).filter((ichunkaccess) -> {
+                    return ichunkaccess instanceof ImposterProtoChunk || ichunkaccess instanceof LevelChunk;
+                }).filter(this::save).forEach((ichunkaccess) -> {
+                    onChunkSave.run(); // Paper - do not overload I/O threads with too much work when saving
+                    mutableboolean.setTrue();
                 });
-            } while(mutableBoolean.isTrue());
+            } while (mutableboolean.isTrue());
 
             this.processUnloads(() -> {
                 return true;
             });
-            this.flushWorker();
+            this.level.asyncChunkTaskManager.flush(); // Paper - flush to preserve behavior compat with pre-async behaviour
+//            this.i(); // Paper - nuke IOWorker
         } else {
-            this.visibleChunkMap.values().stream().filter(ChunkHolder::wasAccessibleSinceLastSave).forEach((chunkHolder) -> {
-                ChunkAccess chunkAccess = chunkHolder.getChunkToSave().getNow((ChunkAccess)null);
-                if (chunkAccess instanceof ImposterProtoChunk || chunkAccess instanceof LevelChunk) {
-                    this.save(chunkAccess);
-                    chunkHolder.refreshAccessibility();
+            this.updatingChunks.getVisibleValuesCopy().stream().filter(ChunkHolder::wasAccessibleSinceLastSave).forEach((playerchunk) -> { // Paper
+                ChunkAccess ichunkaccess = (ChunkAccess) playerchunk.getChunkToSave().getNow(null); // CraftBukkit - decompile error
+
+                if (ichunkaccess instanceof ImposterProtoChunk || ichunkaccess instanceof LevelChunk) {
+                    this.save(ichunkaccess);
+                    playerchunk.refreshAccessibility();
                 }
 
             });
@@ -365,66 +1006,161 @@
 
     }
 
+    private static final double UNLOAD_QUEUE_RESIZE_FACTOR = 0.90; // Spigot // Paper - unload more
+
     protected void tick(BooleanSupplier shouldKeepTicking) {
-        ProfilerFiller profilerFiller = this.level.getProfiler();
-        profilerFiller.push("poi");
+        ProfilerFiller gameprofilerfiller = this.level.getProfiler();
+
+        try (Timing ignored = this.level.timings.poiUnload.startTiming()) { // Paper
+        gameprofilerfiller.push("poi");
         this.poiManager.tick(shouldKeepTicking);
-        profilerFiller.popPush("chunk_unload");
+        } // Paper
+        gameprofilerfiller.popPush("chunk_unload");
         if (!this.level.noSave()) {
+            try (Timing ignored = this.level.timings.chunkUnload.startTiming()) { // Paper
             this.processUnloads(shouldKeepTicking);
+            }// Paper
         }
 
-        profilerFiller.pop();
+        gameprofilerfiller.pop();
     }
 
     private void processUnloads(BooleanSupplier shouldKeepTicking) {
-        LongIterator longIterator = this.toDrop.iterator();
+        LongIterator longiterator = this.toDrop.iterator();
+        // Spigot start
+        org.spigotmc.SlackActivityAccountant activityAccountant = this.level.getServer().slackActivityAccountant;
+        activityAccountant.startActivity(0.5);
+        int targetSize = Math.min(this.toDrop.size() - 100,  (int) (this.toDrop.size() * ChunkMap.UNLOAD_QUEUE_RESIZE_FACTOR)); // Paper - Make more aggressive
+        // Spigot end
+        while (longiterator.hasNext()) { // Spigot
+            long j = longiterator.nextLong();
+            longiterator.remove(); // Spigot
+            ChunkHolder playerchunk = this.updatingChunks.queueRemove(j); // Paper - Don't copy
 
-        for(int i = 0; longIterator.hasNext() && (shouldKeepTicking.getAsBoolean() || i < 200 || this.toDrop.size() > 2000); longIterator.remove()) {
-            long l = longIterator.nextLong();
-            ChunkHolder chunkHolder = this.updatingChunkMap.remove(l);
-            if (chunkHolder != null) {
-                this.pendingUnloads.put(l, chunkHolder);
+            if (playerchunk != null) {
+                this.pendingUnloads.put(j, playerchunk);
                 this.modified = true;
-                ++i;
-                this.scheduleUnload(l, chunkHolder);
+                this.scheduleUnload(j, playerchunk); // Paper - Move up - don't leak chunks
+                // Spigot start
+                if (!shouldKeepTicking.getAsBoolean() && this.toDrop.size() <= targetSize && activityAccountant.activityTimeIsExhausted()) {
+                    break;
+                }
+                // Spigot end
+                //this.a(j, playerchunk); // Paper - move up because spigot did a dumb
             }
         }
+        activityAccountant.endActivity(); // Spigot
 
         Runnable runnable;
-        while((shouldKeepTicking.getAsBoolean() || this.unloadQueue.size() > 2000) && (runnable = this.unloadQueue.poll()) != null) {
+
+        int queueTarget = Math.min(this.unloadQueue.size() - 100, (int) (this.unloadQueue.size() * UNLOAD_QUEUE_RESIZE_FACTOR)); // Paper - Target this queue as well
+        while ((shouldKeepTicking.getAsBoolean() || this.unloadQueue.size() > queueTarget) && (runnable = (Runnable)this.unloadQueue.poll()) != null) { // Paper - Target this queue as well
             runnable.run();
         }
 
     }
 
+    // Paper start - async chunk save for unload
+    // Note: This is very unsafe to call if the chunk is still in use.
+    // This is also modeled after PlayerChunkMap#save(IChunkAccess, boolean), with the intentional difference being
+    // serializing the chunk is left to a worker thread.
+    private void asyncSave(ChunkAccess chunk) {
+        ChunkPos chunkPos = chunk.getPos();
+        CompoundTag poiData;
+        try (Timing ignored = this.level.timings.chunkUnloadPOISerialization.startTiming()) {
+            poiData = this.getVillagePlace().getData(chunk.getPos());
+        }
+
+        com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.scheduleSave(this.level, chunkPos.x, chunkPos.z,
+            poiData, null, com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY);
+
+        if (!chunk.isUnsaved()) {
+            return;
+        }
+
+        ChunkStatus chunkstatus = chunk.getStatus();
+
+        // Copied from PlayerChunkMap#save(IChunkAccess, boolean)
+        if (chunkstatus.getChunkType() != ChunkStatus.ChunkType.LEVELCHUNK) {
+            // Paper start - Optimize save by using status cache
+            if (chunkstatus == ChunkStatus.EMPTY && chunk.getAllStarts().values().stream().noneMatch(StructureStart::isValid)) {
+                return;
+            }
+        }
+
+        ChunkSerializer.AsyncSaveData asyncSaveData;
+        try (Timing ignored = this.level.timings.chunkUnloadPrepareSave.startTiming()) {
+            asyncSaveData = ChunkSerializer.getAsyncSaveData(this.level, chunk);
+        }
+
+        this.level.asyncChunkTaskManager.scheduleChunkSave(chunkPos.x, chunkPos.z, com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY,
+            asyncSaveData, chunk);
+
+        chunk.setUnsaved(false);
+        chunk.setLastSaved(this.level.getGameTime()); // Paper - track last saved time
+    }
+    // Paper end
+
     private void scheduleUnload(long pos, ChunkHolder holder) {
-        CompletableFuture<ChunkAccess> completableFuture = holder.getChunkToSave();
-        completableFuture.thenAcceptAsync((chunk) -> {
-            CompletableFuture<ChunkAccess> completableFuture2 = holder.getChunkToSave();
-            if (completableFuture2 != completableFuture) {
+        CompletableFuture<ChunkAccess> completablefuture = holder.getChunkToSave();
+        Consumer<ChunkAccess> consumer = (ichunkaccess) -> { // CraftBukkit - decompile error
+            CompletableFuture<ChunkAccess> completablefuture1 = holder.getChunkToSave();
+
+            if (completablefuture1 != completablefuture) {
                 this.scheduleUnload(pos, holder);
             } else {
-                if (this.pendingUnloads.remove(pos, holder) && chunk != null) {
-                    if (chunk instanceof LevelChunk) {
-                        ((LevelChunk)chunk).setLoaded(false);
+                // Paper start - do not allow ticket level changes while unloading chunks
+                org.spigotmc.AsyncCatcher.catchOp("playerchunk unload");
+                boolean unloadingBefore = this.unloadingPlayerChunk;
+                this.unloadingPlayerChunk = true;
+                try {
+                    // Paper end - do not allow ticket level changes while unloading chunks
+                // Paper start
+                boolean removed;
+                if ((removed = this.pendingUnloads.remove(pos, holder)) && ichunkaccess != null) {
+                    for (int index = 0, len = this.regionManagers.size(); index < len; ++index) {
+                        this.regionManagers.get(index).removeChunk(holder.pos.x, holder.pos.z);
+                    }
+                    // Paper end
+                    if (ichunkaccess instanceof LevelChunk) {
+                        ((LevelChunk) ichunkaccess).setLoaded(false);
                     }
 
-                    this.save(chunk);
-                    if (this.entitiesInLevel.remove(pos) && chunk instanceof LevelChunk) {
-                        LevelChunk levelChunk = (LevelChunk)chunk;
-                        this.level.unload(levelChunk);
+                    // Paper start - async chunk saving
+                    try {
+                        this.asyncSave(ichunkaccess);
+                    } catch (ThreadDeath ex) {
+                        throw ex; // bye
+                    } catch (Throwable ex) {
+                        LOGGER.fatal("Failed to prepare async save, attempting synchronous save", ex);
+                        this.save(ichunkaccess);
                     }
+                    // Paper end - async chunk saving
+                    if (this.entitiesInLevel.remove(pos) && ichunkaccess instanceof LevelChunk) {
+                        LevelChunk chunk = (LevelChunk) ichunkaccess;
 
-                    this.lightEngine.updateChunkStatus(chunk.getPos());
+                        this.level.unload(chunk);
+                    }
+                    this.autoSaveQueue.remove(holder); // Paper
+
+                    this.lightEngine.updateChunkStatus(ichunkaccess.getPos());
                     this.lightEngine.tryScheduleUpdate();
-                    this.progressListener.onStatusChange(chunk.getPos(), (ChunkStatus)null);
-                }
+                    this.progressListener.onStatusChange(ichunkaccess.getPos(), (ChunkStatus) null);
+                } else if (removed) { // Paper start
+                    for (int index = 0, len = this.regionManagers.size(); index < len; ++index) {
+                        this.regionManagers.get(index).removeChunk(holder.pos.x, holder.pos.z);
+                    }
+                } // Paper end
+                } finally { this.unloadingPlayerChunk = unloadingBefore; } // Paper - do not allow ticket level changes while unloading chunks
 
             }
-        }, this.unloadQueue::add).whenComplete((void_, throwable) -> {
+        };
+        Queue queue = this.unloadQueue;
+
+        Objects.requireNonNull(this.unloadQueue);
+        completablefuture.thenAcceptAsync(consumer, queue::add).whenComplete((ovoid, throwable) -> {
             if (throwable != null) {
-                LOGGER.error("Failed to save chunk {}", holder.getPos(), throwable);
+                ChunkMap.LOGGER.error("Failed to save chunk {}", holder.getPos(), throwable);
             }
 
         });
@@ -434,107 +1170,183 @@
         if (!this.modified) {
             return false;
         } else {
-            this.visibleChunkMap = this.updatingChunkMap.clone();
+            // Paper start - Don't copy
+            synchronized (this.updatingChunks) {
+                this.updatingChunks.performUpdates();
+            }
+            // Paper end - Don't copy
+
             this.modified = false;
             return true;
         }
     }
 
     public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> schedule(ChunkHolder holder, ChunkStatus requiredStatus) {
-        ChunkPos chunkPos = holder.getPos();
+        ChunkPos chunkcoordintpair = holder.getPos();
+
         if (requiredStatus == ChunkStatus.EMPTY) {
-            return this.scheduleChunkLoad(chunkPos);
+            return this.scheduleChunkLoad(chunkcoordintpair);
         } else {
+            // Paper start - revert 1.17 chunk system changes
+            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> future = holder.getOrScheduleFuture(requiredStatus.getParent(), this);
+        return future.thenComposeAsync((either) -> {
+            Optional<ChunkAccess> optional = either.left();
+            if (!optional.isPresent()) {
+                return CompletableFuture.completedFuture(either);
+            }
+            // Paper end - revert 1.17 chunk system changes
             if (requiredStatus == ChunkStatus.LIGHT) {
-                this.distanceManager.addTicket(TicketType.LIGHT, chunkPos, 33 + ChunkStatus.getDistance(ChunkStatus.LIGHT), chunkPos);
+                this.distanceManager.addTicket(TicketType.LIGHT, chunkcoordintpair, 33 + ChunkStatus.getDistance(ChunkStatus.LIGHT), chunkcoordintpair);
             }
 
-            Optional<ChunkAccess> optional = holder.getOrScheduleFuture(requiredStatus.getParent(), this).getNow(ChunkHolder.UNLOADED_CHUNK).left();
-            if (optional.isPresent() && optional.get().getStatus().isOrAfter(requiredStatus)) {
-                CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completableFuture = requiredStatus.load(this.level, this.structureManager, this.lightEngine, (chunkAccess) -> {
+            // Paper - revert 1.17 chunk system changes
+
+            if (optional.isPresent() && ((ChunkAccess) optional.get()).getStatus().isOrAfter(requiredStatus)) {
+                CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = requiredStatus.load(this.level, this.structureManager, this.lightEngine, (ichunkaccess) -> {
                     return this.protoChunkToFullChunk(holder);
-                }, optional.get());
-                this.progressListener.onStatusChange(chunkPos, requiredStatus);
-                return completableFuture;
+                }, (ChunkAccess) optional.get());
+
+                this.progressListener.onStatusChange(chunkcoordintpair, requiredStatus);
+                return completablefuture;
             } else {
                 return this.scheduleChunkGeneration(holder, requiredStatus);
             }
+        }, this.mainThreadExecutor).thenComposeAsync(CompletableFuture::completedFuture, this.mainThreadExecutor); // Paper - revert 1.17 chunk system changes
         }
     }
 
     private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> scheduleChunkLoad(ChunkPos pos) {
-        return CompletableFuture.supplyAsync(() -> {
-            try {
+        // Paper start - Async chunk io
+        final java.util.function.BiFunction<ChunkSerializer.InProgressChunkHolder, Throwable, Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> syncLoadComplete = (chunkHolder, ioThrowable) -> {
+            try (Timing ignored = this.level.timings.chunkLoad.startTimingIfSync()) { // Paper
                 this.level.getProfiler().incrementCounter("chunkLoad");
-                CompoundTag compoundTag = this.readChunk(pos);
-                if (compoundTag != null) {
-                    boolean bl = compoundTag.contains("Level", 10) && compoundTag.getCompound("Level").contains("Status", 8);
-                    if (bl) {
-                        ChunkAccess chunkAccess = ChunkSerializer.read(this.level, this.structureManager, this.poiManager, pos, compoundTag);
-                        this.markPosition(pos, chunkAccess.getStatus().getChunkType());
-                        return Either.left(chunkAccess);
+                // Paper start
+                if (ioThrowable != null) {
+                    com.destroystokyo.paper.util.SneakyThrow.sneaky(ioThrowable);
+                }
+
+                this.getVillagePlace().loadInData(pos, chunkHolder.poiData);
+                chunkHolder.tasks.forEach(Runnable::run);
+                // Paper end
+
+                if (chunkHolder.protoChunk != null) {try (Timing ignored2 = this.level.timings.chunkLoadLevelTimer.startTimingIfSync()) { // Paper start - timings // Paper - chunk is created async
+
+                    if (true) {
+                        ProtoChunk protochunk = chunkHolder.protoChunk;
+
+                        this.markPosition(pos, protochunk.getStatus().getChunkType());
+                        return Either.left(protochunk);
                     }
 
-                    LOGGER.error("Chunk file at {} is missing level data, skipping", (Object)pos);
-                }
-            } catch (ReportedException var5) {
-                Throwable throwable = var5.getCause();
+                    ChunkMap.LOGGER.error("Chunk file at {} is missing level data, skipping", pos);
+                }} // Paper
+            } catch (ReportedException reportedexception) {
+                Throwable throwable = reportedexception.getCause();
+
                 if (!(throwable instanceof IOException)) {
                     this.markPositionReplaceable(pos);
-                    throw var5;
+                    throw reportedexception;
                 }
 
-                LOGGER.error("Couldn't load chunk {}", pos, throwable);
-            } catch (Exception var6) {
-                LOGGER.error("Couldn't load chunk {}", pos, var6);
+                ChunkMap.LOGGER.error("Couldn't load chunk {}", pos, throwable);
+            } catch (Exception exception) {
+                ChunkMap.LOGGER.error("Couldn't load chunk {}", pos, exception);
             }
 
             this.markPositionReplaceable(pos);
-            return Either.left(new ProtoChunk(pos, UpgradeData.EMPTY, this.level));
-        }, this.mainThreadExecutor);
+            return Either.left(new ProtoChunk(pos, UpgradeData.EMPTY, this.level, this.level)); // Paper - add level
+            // Paper start - Async chunk io
+        };
+        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> ret = new CompletableFuture<>();
+
+        Consumer<ChunkSerializer.InProgressChunkHolder> chunkHolderConsumer = (ChunkSerializer.InProgressChunkHolder holder) -> {
+            // Go into the chunk load queue and not server task queue so we can be popped out even faster.
+            com.destroystokyo.paper.io.chunk.ChunkTaskManager.queueChunkWaitTask(() -> {
+                try {
+                    ret.complete(syncLoadComplete.apply(holder, null));
+                } catch (Exception e) {
+                    ret.completeExceptionally(e);
+                }
+            });
+        };
+
+        CompletableFuture<CompoundTag> chunkSaveFuture = this.level.asyncChunkTaskManager.getChunkSaveFuture(pos.x, pos.z);
+        // Paper start
+        ChunkHolder playerChunk = getUpdatingChunkIfPresent(pos.toLong());
+        int chunkPriority = playerChunk != null ? playerChunk.requestedPriority : 33;
+        int priority = com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY;
+
+        if (chunkPriority <= 10) {
+            priority = com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY;
+        } else if (chunkPriority <= 20) {
+            priority = com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGH_PRIORITY;
+        }
+        boolean isHighestPriority = priority == com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY;
+        // Paper end
+        if (chunkSaveFuture != null) {
+            this.level.asyncChunkTaskManager.scheduleChunkLoad(pos.x, pos.z, priority, chunkHolderConsumer, isHighestPriority, chunkSaveFuture); // Paper
+        } else {
+            this.level.asyncChunkTaskManager.scheduleChunkLoad(pos.x, pos.z, priority, chunkHolderConsumer, isHighestPriority); // Paper
+        }
+        this.level.asyncChunkTaskManager.raisePriority(pos.x, pos.z, priority); // Paper
+        return ret;
+        // Paper end
     }
 
-    private void markPositionReplaceable(ChunkPos chunkPos) {
-        this.chunkTypeCache.put(chunkPos.toLong(), (byte)-1);
+    private void markPositionReplaceable(ChunkPos chunkcoordintpair) {
+        this.chunkTypeCache.put(chunkcoordintpair.toLong(), (byte) -1);
     }
 
-    private byte markPosition(ChunkPos chunkPos, ChunkStatus.ChunkType chunkType) {
-        return this.chunkTypeCache.put(chunkPos.toLong(), (byte)(chunkType == ChunkStatus.ChunkType.PROTOCHUNK ? -1 : 1));
+    private byte markPosition(ChunkPos chunkcoordintpair, ChunkStatus.ChunkType chunkstatus_type) {
+        return this.chunkTypeCache.put(chunkcoordintpair.toLong(), (byte) (chunkstatus_type == ChunkStatus.ChunkType.PROTOCHUNK ? -1 : 1));
     }
 
     private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> scheduleChunkGeneration(ChunkHolder holder, ChunkStatus requiredStatus) {
-        ChunkPos chunkPos = holder.getPos();
-        CompletableFuture<Either<List<ChunkAccess>, ChunkHolder.ChunkLoadingFailure>> completableFuture = this.getChunkRangeFuture(chunkPos, requiredStatus.getRange(), (i) -> {
+        ChunkPos chunkcoordintpair = holder.getPos();
+        CompletableFuture<Either<List<ChunkAccess>, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getChunkRangeFuture(chunkcoordintpair, requiredStatus.getRange(), (i) -> {
             return this.getDependencyStatus(requiredStatus, i);
         });
+
         this.level.getProfiler().incrementCounter(() -> {
             return "chunkGenerate " + requiredStatus.getName();
         });
         Executor executor = (runnable) -> {
+            // Paper start - optimize chunk status progression without jumping through thread pool
+            if (holder.canAdvanceStatus()) {
+                this.mainInvokingExecutor.execute(runnable);
+                return;
+            }
+            // Paper end
             this.worldgenMailbox.tell(ChunkTaskPriorityQueueSorter.message(holder, runnable));
         };
-        return completableFuture.thenComposeAsync((either) -> {
-            return either.map((list) -> {
+
+        return completablefuture.thenComposeAsync((either) -> {
+            return (CompletionStage) either.map((list) -> {
                 try {
-                    CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completableFuture = requiredStatus.generate(executor, this.level, this.generator, this.structureManager, this.lightEngine, (chunkAccess) -> {
+                    CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture1 = requiredStatus.generate(executor, this.level, this.generator, this.structureManager, this.lightEngine, (ichunkaccess) -> {
                         return this.protoChunkToFullChunk(holder);
                     }, list);
-                    this.progressListener.onStatusChange(chunkPos, requiredStatus);
-                    return completableFuture;
-                } catch (Exception var9) {
-                    var9.getStackTrace();
-                    CrashReport crashReport = CrashReport.forThrowable(var9, "Exception generating new chunk");
-                    CrashReportCategory crashReportCategory = crashReport.addCategory("Chunk to be generated");
-                    crashReportCategory.setDetail("Location", String.format("%d,%d", chunkPos.x, chunkPos.z));
-                    crashReportCategory.setDetail("Position hash", ChunkPos.asLong(chunkPos.x, chunkPos.z));
-                    crashReportCategory.setDetail("Generator", this.generator);
-                    throw new ReportedException(crashReport);
+
+                    this.progressListener.onStatusChange(chunkcoordintpair, requiredStatus);
+                    return completablefuture1;
+                } catch (Exception exception) {
+                    exception.getStackTrace();
+                    CrashReport crashreport = CrashReport.forThrowable(exception, "Exception generating new chunk");
+                    CrashReportCategory crashreportsystemdetails = crashreport.addCategory("Chunk to be generated");
+
+                    crashreportsystemdetails.setDetail("Location", (Object) String.format("%d,%d", chunkcoordintpair.x, chunkcoordintpair.z));
+                    crashreportsystemdetails.setDetail("Position hash", (Object) ChunkPos.asLong(chunkcoordintpair.x, chunkcoordintpair.z));
+                    crashreportsystemdetails.setDetail("Generator", (Object) this.generator);
+                    throw new ReportedException(crashreport);
                 }
-            }, (chunkLoadingFailure) -> {
-                this.releaseLightTicket(chunkPos);
-                return CompletableFuture.completedFuture(Either.right(chunkLoadingFailure));
+            }, (playerchunk_failure) -> {
+                this.releaseLightTicket(chunkcoordintpair);
+                return CompletableFuture.completedFuture(Either.right(playerchunk_failure));
             });
-        }, executor);
+        }, executor).thenComposeAsync((either) -> { // Paper start - force competion on the main thread
+            return CompletableFuture.completedFuture(either);
+        }, this.mainThreadExecutor); // use the main executor, we want to ensure only one chunk callback can be completed per runnable execute
+        // Paper end - force competion on the main thread
     }
 
     protected void releaseLightTicket(ChunkPos pos) {
@@ -546,94 +1358,154 @@
     }
 
     private ChunkStatus getDependencyStatus(ChunkStatus centerChunkTargetStatus, int distance) {
-        ChunkStatus chunkStatus;
+        ChunkStatus chunkstatus1;
+
         if (distance == 0) {
-            chunkStatus = centerChunkTargetStatus.getParent();
+            chunkstatus1 = centerChunkTargetStatus.getParent();
         } else {
-            chunkStatus = ChunkStatus.getStatusAroundFullChunk(ChunkStatus.getDistance(centerChunkTargetStatus) + distance);
+            chunkstatus1 = ChunkStatus.getStatusAroundFullChunk(ChunkStatus.getDistance(centerChunkTargetStatus) + distance);
         }
 
-        return chunkStatus;
+        return chunkstatus1;
     }
 
-    private static void postLoadProtoChunk(ServerLevel serverLevel, List<CompoundTag> list) {
+    private static void postLoadProtoChunk(ServerLevel worldserver, List<CompoundTag> list) {
         if (!list.isEmpty()) {
-            serverLevel.addWorldGenChunkEntities(EntityType.loadEntitiesRecursive(list, serverLevel));
+            // CraftBukkit start - these are spawned serialized (DefinedStructure) and we don't call an add event below at the moment due to ordering complexities
+            worldserver.addWorldGenChunkEntities(EntityType.loadEntitiesRecursive(list, (Level) worldserver).filter((entity) -> {
+                boolean needsRemoval = false;
+                net.minecraft.server.dedicated.DedicatedServer server = worldserver.getCraftServer().getServer();
+                if (!server.areNpcsEnabled() && entity instanceof net.minecraft.world.entity.npc.Npc) {
+                    entity.discard();
+                    needsRemoval = true;
+                }
+                if (!server.isSpawningAnimals() && (entity instanceof net.minecraft.world.entity.animal.Animal || entity instanceof net.minecraft.world.entity.animal.WaterAnimal)) {
+                    entity.discard();
+                    needsRemoval = true;
+                }
+                checkDupeUUID(worldserver, entity); // Paper
+                return !needsRemoval;
+            }));
+            // CraftBukkit end
         }
 
     }
 
-    private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> protoChunkToFullChunk(ChunkHolder chunkHolder) {
-        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completableFuture = chunkHolder.getFutureIfPresentUnchecked(ChunkStatus.FULL.getParent());
-        return completableFuture.thenApplyAsync((either) -> {
-            ChunkStatus chunkStatus = ChunkHolder.getStatus(chunkHolder.getTicketLevel());
-            return !chunkStatus.isOrAfter(ChunkStatus.FULL) ? ChunkHolder.UNLOADED_CHUNK : either.mapLeft((chunkAccess) -> {
-                ChunkPos chunkPos = chunkHolder.getPos();
-                ProtoChunk protoChunk = (ProtoChunk)chunkAccess;
-                LevelChunk levelChunk;
-                if (protoChunk instanceof ImposterProtoChunk) {
-                    levelChunk = ((ImposterProtoChunk)protoChunk).getWrapped();
+    private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> protoChunkToFullChunk(ChunkHolder playerchunk) {
+        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = playerchunk.getFutureIfPresentUnchecked(ChunkStatus.FULL.getParent());
+
+        return completablefuture.thenApplyAsync((either) -> {
+            ChunkStatus chunkstatus = ChunkHolder.getStatus(playerchunk.getTicketLevel());
+
+            return !chunkstatus.isOrAfter(ChunkStatus.FULL) ? ChunkHolder.UNLOADED_CHUNK : either.mapLeft((ichunkaccess) -> {
+            try (Timing ignored = level.timings.chunkPostLoad.startTimingIfSync()) { // Paper
+                ChunkPos chunkcoordintpair = playerchunk.getPos();
+                ProtoChunk protochunk = (ProtoChunk) ichunkaccess;
+                LevelChunk chunk;
+
+                if (protochunk instanceof ImposterProtoChunk) {
+                    chunk = ((ImposterProtoChunk) protochunk).getWrapped();
                 } else {
-                    levelChunk = new LevelChunk(this.level, protoChunk, (levelChunk) -> {
-                        postLoadProtoChunk(this.level, protoChunk.getEntities());
+                    chunk = new LevelChunk(this.level, protochunk, (chunk1) -> {
+                        ChunkMap.postLoadProtoChunk(this.level, protochunk.getEntities());
                     });
-                    chunkHolder.replaceProtoChunk(new ImposterProtoChunk(levelChunk));
+                    playerchunk.replaceProtoChunk(new ImposterProtoChunk(chunk));
                 }
 
-                levelChunk.setFullStatus(() -> {
-                    return ChunkHolder.getFullChunkStatus(chunkHolder.getTicketLevel());
+                chunk.setFullStatus(() -> {
+                    return ChunkHolder.getFullChunkStatus(playerchunk.getTicketLevel());
                 });
-                levelChunk.runPostLoad();
-                if (this.entitiesInLevel.add(chunkPos.toLong())) {
-                    levelChunk.setLoaded(true);
-                    levelChunk.registerAllBlockEntitiesAfterLevelLoad();
+                chunk.runPostLoad();
+                if (this.entitiesInLevel.add(chunkcoordintpair.toLong())) {
+                    chunk.setLoaded(true);
+                    chunk.registerAllBlockEntitiesAfterLevelLoad();
                 }
 
-                return levelChunk;
+                return chunk;
+                } // Paper
             });
         }, (runnable) -> {
-            this.mainThreadMailbox.tell(ChunkTaskPriorityQueueSorter.message(runnable, chunkHolder.getPos().toLong(), chunkHolder::getTicketLevel));
+            ProcessorHandle mailbox = this.mainThreadMailbox;
+            long i = playerchunk.getPos().toLong();
+
+            Objects.requireNonNull(playerchunk);
+            mailbox.tell(ChunkTaskPriorityQueueSorter.message(runnable, i, () -> 1)); // Paper - final loads are always urgent!
         });
     }
 
+    // Paper start
+    private static void checkDupeUUID(ServerLevel level, Entity entity) {
+        PaperWorldConfig.DuplicateUUIDMode mode = level.paperConfig.duplicateUUIDMode;
+        if (mode != PaperWorldConfig.DuplicateUUIDMode.WARN
+            && mode != PaperWorldConfig.DuplicateUUIDMode.DELETE
+            && mode != PaperWorldConfig.DuplicateUUIDMode.SAFE_REGEN) {
+            return;
+        }
+        Entity other = level.getEntity(entity.getUUID());
+
+        if (mode == PaperWorldConfig.DuplicateUUIDMode.SAFE_REGEN && other != null && !other.isRemoved()
+            && Objects.equals(other.getEncodeId(), entity.getEncodeId())
+            && entity.getBukkitEntity().getLocation().distance(other.getBukkitEntity().getLocation()) < level.paperConfig.duplicateUUIDDeleteRange
+        ) {
+            if (Level.DEBUG_ENTITIES) LOGGER.warn("[DUPE-UUID] Duplicate UUID found used by " + other + ", deleted entity " + entity + " because it was near the duplicate and likely an actual duplicate. See https://github.com/PaperMC/Paper/issues/1223 for discussion on what this is about.");
+            entity.discard();
+            return;
+        }
+        if (other != null && !other.isRemoved()) {
+            switch (mode) {
+                case SAFE_REGEN: {
+                    entity.setUUID(UUID.randomUUID());
+                    if (Level.DEBUG_ENTITIES) LOGGER.warn("[DUPE-UUID] Duplicate UUID found used by " + other + ", regenerated UUID for " + entity + ". See https://github.com/PaperMC/Paper/issues/1223 for discussion on what this is about.");
+                    break;
+                }
+                case DELETE: {
+                    if (Level.DEBUG_ENTITIES) LOGGER.warn("[DUPE-UUID] Duplicate UUID found used by " + other + ", deleted entity " + entity + ". See https://github.com/PaperMC/Paper/issues/1223 for discussion on what this is about.");
+                    entity.discard();
+                    break;
+                }
+                default:
+                    if (Level.DEBUG_ENTITIES) LOGGER.warn("[DUPE-UUID] Duplicate UUID found used by " + other + ", doing nothing to " + entity + ". See https://github.com/PaperMC/Paper/issues/1223 for discussion on what this is about.");
+                    break;
+            }
+        }
+    }
+    // Paper end
     public CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> prepareTickingChunk(ChunkHolder holder) {
-        ChunkPos chunkPos = holder.getPos();
-        CompletableFuture<Either<List<ChunkAccess>, ChunkHolder.ChunkLoadingFailure>> completableFuture = this.getChunkRangeFuture(chunkPos, 1, (i) -> {
+        ChunkPos chunkcoordintpair = holder.getPos();
+        CompletableFuture<Either<List<ChunkAccess>, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getChunkRangeFuture(chunkcoordintpair, 1, (i) -> {
             return ChunkStatus.FULL;
         });
-        CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> completableFuture2 = completableFuture.thenApplyAsync((either) -> {
+        CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> completablefuture1 = completablefuture.thenApplyAsync((either) -> {
             return either.flatMap((list) -> {
-                LevelChunk levelChunk = (LevelChunk)list.get(list.size() / 2);
-                levelChunk.postProcessGeneration();
-                return Either.left(levelChunk);
+                LevelChunk chunk = (LevelChunk) list.get(list.size() / 2);
+
+                chunk.postProcessGeneration();
+                return Either.left(chunk);
             });
         }, (runnable) -> {
-            this.mainThreadMailbox.tell(ChunkTaskPriorityQueueSorter.message(holder, runnable));
+            this.mainThreadMailbox.tell(ChunkTaskPriorityQueueSorter.message(holder, () -> ChunkMap.this.chunkLoadConversionCallbackExecutor.execute(runnable))); // Paper - delay running Chunk post processing until outside of the sorter to prevent a deadlock scenario when post processing causes another chunk request.
         });
-        completableFuture2.thenAcceptAsync((either) -> {
-            either.ifLeft((levelChunk) -> {
+
+        completablefuture1.thenAcceptAsync((either) -> {
+            either.ifLeft((chunk) -> {
                 this.tickingGenerated.getAndIncrement();
-                Packet<?>[] packets = new Packet[2];
-                this.getPlayers(chunkPos, false).forEach((serverPlayer) -> {
-                    this.playerLoadedChunk(serverPlayer, packets, levelChunk);
-                });
+                // Paper - no-tick view distance - moved to Chunk neighbour update
             });
         }, (runnable) -> {
-            this.mainThreadMailbox.tell(ChunkTaskPriorityQueueSorter.message(holder, runnable));
+            this.mainThreadMailbox.tell(ChunkTaskPriorityQueueSorter.message(holder, runnable)); // Paper - diff on change, this is the scheduling method copied in Chunk used to schedule chunk broadcasts (on change it needs to be copied again)
         });
-        return completableFuture2;
+        return completablefuture1;
     }
 
-    public CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> prepareAccessibleChunk(ChunkHolder chunkHolder) {
-        return this.getChunkRangeFuture(chunkHolder.getPos(), 1, ChunkStatus::getStatusAroundFullChunk).thenApplyAsync((either) -> {
+    public CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> prepareAccessibleChunk(ChunkHolder playerchunk) {
+        return this.getChunkRangeFuture(playerchunk.getPos(), 1, ChunkStatus::getStatusAroundFullChunk).thenApplyAsync((either) -> {
             return either.mapLeft((list) -> {
-                LevelChunk levelChunk = (LevelChunk)list.get(list.size() / 2);
-                levelChunk.unpackTicks();
-                return levelChunk;
+                LevelChunk chunk = (LevelChunk) list.get(list.size() / 2);
+
+                chunk.unpackTicks();
+                return chunk;
             });
-        }, (runnable) -> {
-            this.mainThreadMailbox.tell(ChunkTaskPriorityQueueSorter.message(chunkHolder, runnable));
-        });
+        }, this.mainThreadExecutor); // Paper - queue to execute immediately so this doesn't delay chunk unloading
     }
 
     public int getTickingGenerated() {
@@ -641,89 +1513,105 @@
     }
 
     public boolean save(ChunkAccess chunk) {
+        try (co.aikar.timings.Timing ignored = this.level.timings.chunkSave.startTiming()) { // Paper
         this.poiManager.flush(chunk.getPos());
         if (!chunk.isUnsaved()) {
             return false;
         } else {
+            chunk.setLastSaved(this.level.getGameTime()); // Paper - track save time
             chunk.setUnsaved(false);
-            ChunkPos chunkPos = chunk.getPos();
+            ChunkPos chunkcoordintpair = chunk.getPos();
 
             try {
-                ChunkStatus chunkStatus = chunk.getStatus();
-                if (chunkStatus.getChunkType() != ChunkStatus.ChunkType.LEVELCHUNK) {
-                    if (this.isExistingChunkFull(chunkPos)) {
+                ChunkStatus chunkstatus = chunk.getStatus();
+
+                if (chunkstatus.getChunkType() != ChunkStatus.ChunkType.LEVELCHUNK) {
+                    if (false && this.isExistingChunkFull(chunkcoordintpair)) { // Paper
                         return false;
                     }
 
-                    if (chunkStatus == ChunkStatus.EMPTY && chunk.getAllStarts().values().stream().noneMatch(StructureStart::isValid)) {
+                    if (chunkstatus == ChunkStatus.EMPTY && chunk.getAllStarts().values().stream().noneMatch(StructureStart::isValid)) {
                         return false;
                     }
                 }
 
                 this.level.getProfiler().incrementCounter("chunkSave");
-                CompoundTag compoundTag = ChunkSerializer.write(this.level, chunk);
-                this.write(chunkPos, compoundTag);
-                this.markPosition(chunkPos, chunkStatus.getChunkType());
+                CompoundTag nbttagcompound;
+                try (co.aikar.timings.Timing ignored1 = this.level.timings.chunkSaveDataSerialization.startTiming()) { // Paper
+                    nbttagcompound = ChunkSerializer.write(this.level, chunk);
+                } // Paper
+
+
+                // Paper start - async chunk io
+                com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.scheduleSave(this.level, chunkcoordintpair.x, chunkcoordintpair.z,
+                    null, nbttagcompound, com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY);
+                // Paper end - async chunk io
+                this.markPosition(chunkcoordintpair, chunkstatus.getChunkType());
                 return true;
-            } catch (Exception var5) {
-                LOGGER.error("Failed to save chunk {},{}", chunkPos.x, chunkPos.z, var5);
+            } catch (Exception exception) {
+                ChunkMap.LOGGER.error("Failed to save chunk {},{}", chunkcoordintpair.x, chunkcoordintpair.z, exception);
+                com.destroystokyo.paper.exception.ServerInternalException.reportInternalException(exception); // Paper
                 return false;
             }
         }
+        } // Paper
     }
 
-    private boolean isExistingChunkFull(ChunkPos chunkPos) {
-        byte b = this.chunkTypeCache.get(chunkPos.toLong());
-        if (b != 0) {
-            return b == 1;
+    private boolean isExistingChunkFull(ChunkPos chunkcoordintpair) {
+        byte b0 = this.chunkTypeCache.get(chunkcoordintpair.toLong());
+
+        if (b0 != 0) {
+            return b0 == 1;
         } else {
-            CompoundTag compoundTag;
+            CompoundTag nbttagcompound;
+
             try {
-                compoundTag = this.readChunk(chunkPos);
-                if (compoundTag == null) {
-                    this.markPositionReplaceable(chunkPos);
+                nbttagcompound = this.readChunk(chunkcoordintpair);
+                if (nbttagcompound == null) {
+                    this.markPositionReplaceable(chunkcoordintpair);
                     return false;
                 }
-            } catch (Exception var5) {
-                LOGGER.error("Failed to read chunk {}", chunkPos, var5);
-                this.markPositionReplaceable(chunkPos);
+            } catch (Exception exception) {
+                ChunkMap.LOGGER.error("Failed to read chunk {}", chunkcoordintpair, exception);
+                this.markPositionReplaceable(chunkcoordintpair);
                 return false;
             }
 
-            ChunkStatus.ChunkType chunkType = ChunkSerializer.getChunkTypeFromTag(compoundTag);
-            return this.markPosition(chunkPos, chunkType) == 1;
+            ChunkStatus.ChunkType chunkstatus_type = ChunkSerializer.getChunkTypeFromTag(nbttagcompound);
+
+            return this.markPosition(chunkcoordintpair, chunkstatus_type) == 1;
         }
     }
 
     public void setViewDistance(int watchDistance) {
-        int i = Mth.clamp(watchDistance + 1, 3, 33);
-        if (i != this.viewDistance) {
-            int j = this.viewDistance;
-            this.viewDistance = i;
-            this.distanceManager.updatePlayerTickets(this.viewDistance);
+        int j = Mth.clamp(watchDistance + 1, 3, 33); // Paper - diff on change, these make the lower view distance limit 2 and the upper 32
 
-            for(ChunkHolder chunkHolder : this.updatingChunkMap.values()) {
-                ChunkPos chunkPos = chunkHolder.getPos();
-                Packet<?>[] packets = new Packet[2];
-                this.getPlayers(chunkPos, false).forEach((serverPlayer) -> {
-                    int j = checkerboardDistance(chunkPos, serverPlayer, true);
-                    boolean bl = j <= j;
-                    boolean bl2 = j <= this.viewDistance;
-                    this.updateChunkTracking(serverPlayer, chunkPos, packets, bl, bl2);
-                });
-            }
+        if (j != this.viewDistance) {
+            int k = this.viewDistance;
+
+            this.viewDistance = j;
+            this.playerChunkManager.setTickDistance(Mth.clamp(watchDistance, 2, 32)); // Paper - replace player loader system
         }
 
     }
 
-    protected void updateChunkTracking(ServerPlayer player, ChunkPos pos, Packet<?>[] packets, boolean withinMaxWatchDistance, boolean withinViewDistance) {
+    // Paper start - no-tick view distance
+    public final void setNoTickViewDistance(int viewDistance) {
+        viewDistance = viewDistance == -1 ? -1 : Mth.clamp(viewDistance, 2, 32);
+        this.playerChunkManager.setLoadDistance(viewDistance == -1 ? -1 : viewDistance + 1); // Paper - replace player loader system - add 1 here, we need an extra one to send to clients for chunks in this viewDistance to render
+
+    }
+
+    public void updateChunkTracking(ServerPlayer player, ChunkPos pos, Packet<?>[] packets, boolean withinMaxWatchDistance, boolean withinViewDistance) { // Paper - public
         if (player.level == this.level) {
             if (withinViewDistance && !withinMaxWatchDistance) {
-                ChunkHolder chunkHolder = this.getVisibleChunkIfPresent(pos.toLong());
-                if (chunkHolder != null) {
-                    LevelChunk levelChunk = chunkHolder.getTickingChunk();
-                    if (levelChunk != null) {
-                        this.playerLoadedChunk(player, packets, levelChunk);
+                ChunkHolder playerchunk = this.getVisibleChunkIfPresent(pos.toLong());
+
+                if (playerchunk != null) {
+                    LevelChunk chunk = playerchunk.getSendingChunk(); // Paper - no-tick view distance
+
+                    if (chunk != null) {
+                        this.playerLoadedChunk(player, packets, chunk);
                     }
 
                     DebugPackets.sendPoiPacketsForChunk(this.level, pos);
@@ -738,211 +1626,399 @@
     }
 
     public int size() {
-        return this.visibleChunkMap.size();
+        return this.updatingChunks.getVisibleMap().size(); // Paper - Don't copy
     }
 
-    protected net.minecraft.server.level.DistanceManager getDistanceManager() {
+    protected DistanceManager getDistanceManager() {
         return this.distanceManager;
     }
 
     protected Iterable<ChunkHolder> getChunks() {
-        return Iterables.unmodifiableIterable(this.visibleChunkMap.values());
+        return Iterables.unmodifiableIterable(this.updatingChunks.getVisibleValuesCopy()); // Paper
     }
 
     void dumpChunks(Writer writer) throws IOException {
-        CsvOutput csvOutput = CsvOutput.builder().addColumn("x").addColumn("z").addColumn("level").addColumn("in_memory").addColumn("status").addColumn("full_status").addColumn("accessible_ready").addColumn("ticking_ready").addColumn("entity_ticking_ready").addColumn("ticket").addColumn("spawning").addColumn("block_entity_count").build(writer);
+        CsvOutput csvwriter = CsvOutput.builder().addColumn("x").addColumn("z").addColumn("level").addColumn("in_memory").addColumn("status").addColumn("full_status").addColumn("accessible_ready").addColumn("ticking_ready").addColumn("entity_ticking_ready").addColumn("ticket").addColumn("spawning").addColumn("block_entity_count").build(writer);
+        ObjectBidirectionalIterator objectbidirectionaliterator = this.updatingChunks.getVisibleMap().clone().long2ObjectEntrySet().fastIterator(); // Paper
 
-        for(Entry<ChunkHolder> entry : this.visibleChunkMap.long2ObjectEntrySet()) {
-            ChunkPos chunkPos = new ChunkPos(entry.getLongKey());
-            ChunkHolder chunkHolder = entry.getValue();
-            Optional<ChunkAccess> optional = Optional.ofNullable(chunkHolder.getLastAvailable());
-            Optional<LevelChunk> optional2 = optional.flatMap((chunk) -> {
-                return chunk instanceof LevelChunk ? Optional.of((LevelChunk)chunk) : Optional.empty();
+        while (objectbidirectionaliterator.hasNext()) {
+            Entry<ChunkHolder> entry = (Entry) objectbidirectionaliterator.next();
+            ChunkPos chunkcoordintpair = new ChunkPos(entry.getLongKey());
+            ChunkHolder playerchunk = (ChunkHolder) entry.getValue();
+            Optional<ChunkAccess> optional = Optional.ofNullable(playerchunk.getLastAvailable());
+            Optional<LevelChunk> optional1 = optional.flatMap((ichunkaccess) -> {
+                return ichunkaccess instanceof LevelChunk ? Optional.of((LevelChunk) ichunkaccess) : Optional.empty();
             });
-            csvOutput.writeRow(chunkPos.x, chunkPos.z, chunkHolder.getTicketLevel(), optional.isPresent(), optional.map(ChunkAccess::getStatus).orElse((ChunkStatus)null), optional2.map(LevelChunk::getFullStatus).orElse((ChunkHolder.FullChunkStatus)null), printFuture(chunkHolder.getFullChunkFuture()), printFuture(chunkHolder.getTickingChunkFuture()), printFuture(chunkHolder.getEntityTickingChunkFuture()), this.distanceManager.getTicketDebugString(entry.getLongKey()), !this.noPlayersCloseForSpawning(chunkPos), optional2.map((levelChunk) -> {
-                return levelChunk.getBlockEntities().size();
+
+            // CraftBukkit - decompile error
+            csvwriter.writeRow(chunkcoordintpair.x, chunkcoordintpair.z, playerchunk.getTicketLevel(), optional.isPresent(), optional.map(ChunkAccess::getStatus).orElse(null), optional1.map(LevelChunk::getFullStatus).orElse(null), ChunkMap.printFuture(playerchunk.getFullChunkFuture()), ChunkMap.printFuture(playerchunk.getTickingChunkFuture()), ChunkMap.printFuture(playerchunk.getEntityTickingChunkFuture()), this.distanceManager.getTicketDebugString(entry.getLongKey()), !this.noPlayersCloseForSpawning(chunkcoordintpair), optional1.map((chunk) -> {
+                return chunk.getBlockEntities().size();
             }).orElse(0));
         }
 
     }
 
-    private static String printFuture(CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> completableFuture) {
+    private static String printFuture(CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> completablefuture) {
         try {
-            Either<LevelChunk, ChunkHolder.ChunkLoadingFailure> either = completableFuture.getNow((Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>)null);
-            return either != null ? either.map((levelChunk) -> {
+            Either<LevelChunk, ChunkHolder.ChunkLoadingFailure> either = (Either) completablefuture.getNow(null); // CraftBukkit - decompile error
+
+            return either != null ? (String) either.map((chunk) -> {
                 return "done";
-            }, (chunkLoadingFailure) -> {
+            }, (playerchunk_failure) -> {
                 return "unloaded";
             }) : "not completed";
-        } catch (CompletionException var2) {
-            return "failed " + var2.getCause().getMessage();
-        } catch (CancellationException var3) {
+        } catch (CompletionException completionexception) {
+            return "failed " + completionexception.getCause().getMessage();
+        } catch (CancellationException cancellationexception) {
             return "cancelled";
         }
     }
 
+    // Paper start - Asynchronous chunk io
+    @Nullable
+    @Override
+    public CompoundTag read(ChunkPos chunkcoordintpair) throws IOException {
+        if (Thread.currentThread() != com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE) {
+            CompoundTag ret = com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE
+                .loadChunkDataAsyncFuture(this.level, chunkcoordintpair.x, chunkcoordintpair.z, com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread(),
+                    false, true, true).join().chunkData;
+
+            if (ret == com.destroystokyo.paper.io.PaperFileIOThread.FAILURE_VALUE) {
+                throw new IOException("See logs for further detail");
+            }
+            return ret;
+        }
+        return super.read(chunkcoordintpair);
+    }
+
+    @Override
+    public void write(ChunkPos chunkcoordintpair, CompoundTag nbttagcompound) throws IOException {
+        if (Thread.currentThread() != com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE) {
+            com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.scheduleSave(
+                this.level, chunkcoordintpair.x, chunkcoordintpair.z, null, nbttagcompound,
+                com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread());
+            return;
+        }
+        super.write(chunkcoordintpair, nbttagcompound);
+    }
+    // Paper end
+
     @Nullable
     public CompoundTag readChunk(ChunkPos pos) throws IOException {
-        CompoundTag compoundTag = this.read(pos);
-        return compoundTag == null ? null : this.upgradeChunkTag(this.level.dimension(), this.overworldDataStorage, compoundTag);
+        CompoundTag nbttagcompound = this.read(pos);
+        // Paper start - Cache chunk status on disk
+        if (nbttagcompound == null) {
+            return null;
+        }
+
+        nbttagcompound = this.getChunkData(this.level.getTypeKey(), this.overworldDataStorage, nbttagcompound, pos, level); // CraftBukkit
+        if (nbttagcompound == null) {
+            return null;
+        }
+
+        this.updateChunkStatusOnDisk(pos, nbttagcompound);
+
+        return nbttagcompound;
+        // Paper end
+    }
+
+    // Paper start - chunk status cache "api"
+    public ChunkStatus getChunkStatusOnDiskIfCached(ChunkPos chunkPos) {
+        RegionFile regionFile = regionFileCache.getRegionFileIfLoaded(chunkPos);
+
+        return regionFile == null ? null : regionFile.getStatusIfCached(chunkPos.x, chunkPos.z);
+    }
+
+    public ChunkStatus getChunkStatusOnDisk(ChunkPos chunkPos) throws IOException {
+        RegionFile regionFile = regionFileCache.getFile(chunkPos, true);
+
+        if (regionFile == null || !regionFileCache.chunkExists(chunkPos)) {
+            return null;
+        }
+
+        ChunkStatus status = regionFile.getStatusIfCached(chunkPos.x, chunkPos.z);
+
+        if (status != null) {
+            return status;
+        }
+
+        this.readChunk(chunkPos);
+
+        return regionFile.getStatusIfCached(chunkPos.x, chunkPos.z);
+    }
+
+    public void updateChunkStatusOnDisk(ChunkPos chunkPos, @Nullable CompoundTag compound) throws IOException {
+        RegionFile regionFile = regionFileCache.getFile(chunkPos, false);
+
+        regionFile.setStatus(chunkPos.x, chunkPos.z, ChunkSerializer.getStatus(compound));
+    }
+
+    public ChunkAccess getUnloadingChunk(int chunkX, int chunkZ) {
+        ChunkHolder chunkHolder = this.pendingUnloads.get(ChunkPos.asLong(chunkX, chunkZ));
+        return chunkHolder == null ? null : chunkHolder.getAvailableChunkNow();
     }
+    // Paper end
 
     boolean noPlayersCloseForSpawning(ChunkPos chunkPos) {
-        long l = chunkPos.toLong();
-        return !this.distanceManager.hasPlayersNearby(l) ? true : this.playerMap.getPlayers(l).noneMatch((serverPlayer) -> {
-            return !serverPlayer.isSpectator() && euclideanDistanceSquared(chunkPos, serverPlayer) < 16384.0D;
-        });
+        // Spigot start
+        return this.isOutsideOfRange(chunkPos, false);
+    }
+
+    // Paper start - optimise isOutsideOfRange
+    final boolean isOutsideOfRange(ChunkPos chunkcoordintpair, boolean reducedRange) {
+        return this.isOutsideOfRange(this.getUpdatingChunkIfPresent(chunkcoordintpair.toLong()), chunkcoordintpair, reducedRange);
+    }
+    final boolean isOutsideOfRange(ChunkHolder playerchunk, ChunkPos chunkcoordintpair, boolean reducedRange) {
+        // this function is so hot that removing the map lookup call can have an order of magnitude impact on its performance
+        // tested and confirmed via System.nanoTime()
+        com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInRange = reducedRange ? playerchunk.playersInMobSpawnRange : playerchunk.playersInChunkTickRange;
+        if (playersInRange == null) {
+            return true;
+        }
+        Object[] backingSet = playersInRange.getBackingSet();
+
+        if (reducedRange) {
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object raw = backingSet[i];
+                if (!(raw instanceof ServerPlayer)) {
+                    continue;
+                }
+                ServerPlayer player = (ServerPlayer) raw;
+                // don't check spectator and whatnot, already handled by mob spawn map update
+                if (player.lastEntitySpawnRadiusSquared > euclideanDistanceSquared(chunkcoordintpair, player)) {
+                    return false; // in range
+                }
+            }
+        } else {
+            final double range = (DistanceManager.MOB_SPAWN_RANGE * 16) * (DistanceManager.MOB_SPAWN_RANGE * 16);
+            // before spigot, mob spawn range was actually mob spawn range + tick range, but it was split
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object raw = backingSet[i];
+                if (!(raw instanceof ServerPlayer)) {
+                    continue;
+                }
+                ServerPlayer player = (ServerPlayer) raw;
+                // don't check spectator and whatnot, already handled by mob spawn map update
+                if (range > euclideanDistanceSquared(chunkcoordintpair, player)) {
+                    return false; // in range
+                }
+            }
+        }
+        // no players in range
+        return true;
     }
+    // Paper end - optimise isOutsideOfRange
 
     private boolean skipPlayer(ServerPlayer player) {
         return player.isSpectator() && !this.level.getGameRules().getBoolean(GameRules.RULE_SPECTATORSGENERATECHUNKS);
     }
 
     void updatePlayerStatus(ServerPlayer player, boolean added) {
-        boolean bl = this.skipPlayer(player);
-        boolean bl2 = this.playerMap.ignoredOrUnknown(player);
+        boolean flag1 = this.skipPlayer(player);
+        boolean flag2 = this.playerMap.ignoredOrUnknown(player);
         int i = SectionPos.blockToSectionCoord(player.getBlockX());
         int j = SectionPos.blockToSectionCoord(player.getBlockZ());
+
         if (added) {
-            this.playerMap.addPlayer(ChunkPos.asLong(i, j), player, bl);
+            this.playerMap.addPlayer(ChunkPos.asLong(i, j), player, flag1);
             this.updatePlayerPos(player);
-            if (!bl) {
-                this.distanceManager.addPlayer(SectionPos.of(player), player);
+            if (!flag1) {
+                this.distanceManager.addPlayer(SectionPos.of((Entity) player), player);
             }
+            this.addPlayerToDistanceMaps(player); // Paper - distance maps
         } else {
-            SectionPos sectionPos = player.getLastSectionPos();
-            this.playerMap.removePlayer(sectionPos.chunk().toLong(), player);
-            if (!bl2) {
-                this.distanceManager.removePlayer(sectionPos, player);
-            }
-        }
+            SectionPos sectionposition = player.getLastSectionPos();
 
-        for(int k = i - this.viewDistance; k <= i + this.viewDistance; ++k) {
-            for(int l = j - this.viewDistance; l <= j + this.viewDistance; ++l) {
-                ChunkPos chunkPos = new ChunkPos(k, l);
-                this.updateChunkTracking(player, chunkPos, new Packet[2], !added, added);
+            this.playerMap.removePlayer(sectionposition.chunk().toLong(), player);
+            if (!flag2) {
+                this.distanceManager.removePlayer(sectionposition, player);
             }
+            this.removePlayerFromDistanceMaps(player); // Paper - distance maps
         }
 
+        // Paper - broadcast view distance map handles this (see remove/add calls above)
+
     }
 
     private SectionPos updatePlayerPos(ServerPlayer player) {
-        SectionPos sectionPos = SectionPos.of(player);
-        player.setLastSectionPos(sectionPos);
-        player.connection.send(new ClientboundSetChunkCacheCenterPacket(sectionPos.x(), sectionPos.z()));
-        return sectionPos;
+        SectionPos sectionposition = SectionPos.of((Entity) player);
+
+        player.setLastSectionPos(sectionposition);
+        // player.connection.send(new ClientboundSetChunkCacheCenterPacket(sectionposition.x(), sectionposition.z())); // Paper - distance map handles this now
+        return sectionposition;
     }
 
     public void move(ServerPlayer player) {
-        for(ChunkMap.TrackedEntity trackedEntity : this.entityMap.values()) {
-            if (trackedEntity.entity == player) {
-                trackedEntity.updatePlayers(this.level.players());
-            } else {
-                trackedEntity.updatePlayer(player);
-            }
-        }
+        // Paper - delay this logic for the entity tracker tick, no need to duplicate it
 
         int i = SectionPos.blockToSectionCoord(player.getBlockX());
         int j = SectionPos.blockToSectionCoord(player.getBlockZ());
-        SectionPos sectionPos = player.getLastSectionPos();
-        SectionPos sectionPos2 = SectionPos.of(player);
-        long l = sectionPos.chunk().toLong();
-        long m = sectionPos2.chunk().toLong();
-        boolean bl = this.playerMap.ignored(player);
-        boolean bl2 = this.skipPlayer(player);
-        boolean bl3 = sectionPos.asLong() != sectionPos2.asLong();
-        if (bl3 || bl != bl2) {
+        SectionPos sectionposition = player.getLastSectionPos();
+        SectionPos sectionposition1 = SectionPos.of((Entity) player);
+        long k = sectionposition.chunk().toLong();
+        long l = sectionposition1.chunk().toLong();
+        boolean flag = this.playerMap.ignored(player);
+        boolean flag1 = this.skipPlayer(player);
+        boolean flag2 = sectionposition.asLong() != sectionposition1.asLong();
+
+        if (flag2 || flag != flag1) {
             this.updatePlayerPos(player);
-            if (!bl) {
-                this.distanceManager.removePlayer(sectionPos, player);
+            if (!flag) {
+                this.distanceManager.removePlayer(sectionposition, player);
             }
 
-            if (!bl2) {
-                this.distanceManager.addPlayer(sectionPos2, player);
+            if (!flag1) {
+                this.distanceManager.addPlayer(sectionposition1, player);
             }
 
-            if (!bl && bl2) {
+            if (!flag && flag1) {
                 this.playerMap.ignorePlayer(player);
             }
 
-            if (bl && !bl2) {
+            if (flag && !flag1) {
                 this.playerMap.unIgnorePlayer(player);
             }
 
-            if (l != m) {
-                this.playerMap.updatePlayer(l, m, player);
+            if (k != l) {
+                this.playerMap.updatePlayer(k, l, player);
             }
         }
 
-        int k = sectionPos.x();
-        int n = sectionPos.z();
-        if (Math.abs(k - i) <= this.viewDistance * 2 && Math.abs(n - j) <= this.viewDistance * 2) {
-            int o = Math.min(i, k) - this.viewDistance;
-            int p = Math.min(j, n) - this.viewDistance;
-            int q = Math.max(i, k) + this.viewDistance;
-            int r = Math.max(j, n) + this.viewDistance;
+        int i1 = sectionposition.x();
+        int j1 = sectionposition.z();
+        int k1;
+        int l1;
 
-            for(int s = o; s <= q; ++s) {
-                for(int t = p; t <= r; ++t) {
-                    ChunkPos chunkPos = new ChunkPos(s, t);
-                    boolean bl4 = checkerboardDistance(chunkPos, k, n) <= this.viewDistance;
-                    boolean bl5 = checkerboardDistance(chunkPos, i, j) <= this.viewDistance;
-                    this.updateChunkTracking(player, chunkPos, new Packet[2], bl4, bl5);
+        /* // Paper start - replaced by distance map
+        if (Math.abs(i1 - i) <= this.viewDistance * 2 && Math.abs(j1 - j) <= this.viewDistance * 2) {
+            k1 = Math.min(i, i1) - this.viewDistance;
+            l1 = Math.min(j, j1) - this.viewDistance;
+            int i2 = Math.max(i, i1) + this.viewDistance;
+            int j2 = Math.max(j, j1) + this.viewDistance;
+
+            for (int k2 = k1; k2 <= i2; ++k2) {
+                for (int l2 = l1; l2 <= j2; ++l2) {
+                    ChunkPos chunkcoordintpair = new ChunkPos(k2, l2);
+                    boolean flag3 = ChunkMap.checkerboardDistance(chunkcoordintpair, i1, j1) <= this.viewDistance;
+                    boolean flag4 = ChunkMap.checkerboardDistance(chunkcoordintpair, i, j) <= this.viewDistance;
+
+                    this.updateChunkTracking(player, chunkcoordintpair, new Packet[2], flag3, flag4);
                 }
             }
         } else {
-            for(int u = k - this.viewDistance; u <= k + this.viewDistance; ++u) {
-                for(int v = n - this.viewDistance; v <= n + this.viewDistance; ++v) {
-                    ChunkPos chunkPos2 = new ChunkPos(u, v);
-                    boolean bl6 = true;
-                    boolean bl7 = false;
-                    this.updateChunkTracking(player, chunkPos2, new Packet[2], true, false);
+            ChunkPos chunkcoordintpair1;
+            boolean flag5;
+            boolean flag6;
+
+            for (k1 = i1 - this.viewDistance; k1 <= i1 + this.viewDistance; ++k1) {
+                for (l1 = j1 - this.viewDistance; l1 <= j1 + this.viewDistance; ++l1) {
+                    chunkcoordintpair1 = new ChunkPos(k1, l1);
+                    flag5 = true;
+                    flag6 = false;
+                    this.updateChunkTracking(player, chunkcoordintpair1, new Packet[2], true, false);
                 }
             }
 
-            for(int w = i - this.viewDistance; w <= i + this.viewDistance; ++w) {
-                for(int x = j - this.viewDistance; x <= j + this.viewDistance; ++x) {
-                    ChunkPos chunkPos3 = new ChunkPos(w, x);
-                    boolean bl8 = false;
-                    boolean bl9 = true;
-                    this.updateChunkTracking(player, chunkPos3, new Packet[2], false, true);
+            for (k1 = i - this.viewDistance; k1 <= i + this.viewDistance; ++k1) {
+                for (l1 = j - this.viewDistance; l1 <= j + this.viewDistance; ++l1) {
+                    chunkcoordintpair1 = new ChunkPos(k1, l1);
+                    flag5 = false;
+                    flag6 = true;
+                    this.updateChunkTracking(player, chunkcoordintpair1, new Packet[2], false, true);
                 }
             }
         }
+        */ // Paper end - replaced by distance map
+
+        this.updateMaps(player); // Paper - distance maps
+        this.playerChunkManager.updatePlayer(player); // Paper - respond to movement immediately
 
     }
 
     @Override
     public Stream<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge) {
-        return this.playerMap.getPlayers(chunkPos.toLong()).filter((serverPlayer) -> {
-            int i = checkerboardDistance(chunkPos, serverPlayer, true);
-            if (i > this.viewDistance) {
-                return false;
-            } else {
-                return !onlyOnWatchDistanceEdge || i == this.viewDistance;
+        // Paper start - per player view distance
+        // there can be potential desync with player's last mapped section and the view distance map, so use the
+        // view distance map here.
+        com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> inRange = this.playerChunkManager.broadcastMap.getObjectsInRange(chunkPos); // Paper - replace player chunk loader system
+
+        if (inRange == null) {
+            return Stream.empty();
+        }
+        // all current cases are inlined so we wont hit this code, it's just in case plugins or future updates use it
+        List<ServerPlayer> players = new java.util.ArrayList<>();
+        Object[] backingSet = inRange.getBackingSet();
+
+        if (onlyOnWatchDistanceEdge) { // flag -> border only
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object temp = backingSet[i];
+                if (!(temp instanceof ServerPlayer)) {
+                    continue;
+                }
+                ServerPlayer player = (ServerPlayer)temp;
+                if (!this.playerChunkManager.isChunkSent(player, chunkPos.x, chunkPos.z)) continue; // Paper - replace player chunk management
+                int viewDistance = this.playerChunkManager.broadcastMap.getLastViewDistance(player); // Paper - replace player chunk loader system
+                long lastPosition = this.playerChunkManager.broadcastMap.getLastCoordinate(player); // Paper - replace player chunk loader system
+
+                int distX = Math.abs(MCUtil.getCoordinateX(lastPosition) - chunkPos.x);
+                int distZ = Math.abs(MCUtil.getCoordinateZ(lastPosition) - chunkPos.z);
+                if (Math.max(distX, distZ) == viewDistance) {
+                    players.add(player);
+                }
             }
-        });
+        } else {
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object temp = backingSet[i];
+                if (!(temp instanceof ServerPlayer)) {
+                    continue;
+                }
+                ServerPlayer player = (ServerPlayer)temp;
+                if (!this.playerChunkManager.isChunkSent(player, chunkPos.x, chunkPos.z)) continue; // Paper - replace player chunk management
+                players.add(player);
+            }
+        }
+        return players.stream();
+        // Paper end - per player view distance
     }
 
     public void addEntity(Entity entity) {
+        org.spigotmc.AsyncCatcher.catchOp("entity track"); // Spigot
+        // Paper start - ignore and warn about illegal addEntity calls instead of crashing server
+        if (!entity.valid || entity.level != this.level || this.entityMap.containsKey(entity.getId())) {
+            new Throwable("[ERROR] Illegal PlayerChunkMap::addEntity for world " + this.level.getWorld().getName()
+                + ": " + entity  + (this.entityMap.containsKey(entity.getId()) ? " ALREADY CONTAINED (This would have crashed your server)" : ""))
+                .printStackTrace();
+            return;
+        }
+        if (entity instanceof ServerPlayer && ((ServerPlayer) entity).supressTrackerForLogin) return; // Delay adding to tracker until after list packets
+        // Paper end
         if (!(entity instanceof EnderDragonPart)) {
-            EntityType<?> entityType = entity.getType();
-            int i = entityType.clientTrackingRange() * 16;
+            EntityType<?> entitytypes = entity.getType();
+            int i = entitytypes.clientTrackingRange() * 16;
+            i = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, i); // Spigot
+
             if (i != 0) {
-                int j = entityType.updateInterval();
+                int j = entitytypes.updateInterval();
+
                 if (this.entityMap.containsKey(entity.getId())) {
-                    throw (IllegalStateException)Util.pauseInIde(new IllegalStateException("Entity is already tracked!"));
+                    throw (IllegalStateException) Util.pauseInIde((Throwable) (new IllegalStateException("Entity is already tracked!")));
                 } else {
-                    ChunkMap.TrackedEntity trackedEntity = new ChunkMap.TrackedEntity(entity, i, j, entityType.trackDeltas());
-                    this.entityMap.put(entity.getId(), trackedEntity);
-                    trackedEntity.updatePlayers(this.level.players());
+                    ChunkMap.TrackedEntity playerchunkmap_entitytracker = new ChunkMap.TrackedEntity(entity, i, j, entitytypes.trackDeltas());
+
+                    entity.tracker = playerchunkmap_entitytracker; // Paper - Fast access to tracker
+                    this.entityMap.put(entity.getId(), playerchunkmap_entitytracker);
+                    playerchunkmap_entitytracker.updatePlayers(entity.getPlayersInTrackRange()); // Paper - don't search all players
                     if (entity instanceof ServerPlayer) {
-                        ServerPlayer serverPlayer = (ServerPlayer)entity;
-                        this.updatePlayerStatus(serverPlayer, true);
+                        ServerPlayer entityplayer = (ServerPlayer) entity;
 
-                        for(ChunkMap.TrackedEntity trackedEntity2 : this.entityMap.values()) {
-                            if (trackedEntity2.entity != serverPlayer) {
-                                trackedEntity2.updatePlayer(serverPlayer);
+                        this.updatePlayerStatus(entityplayer, true);
+                        ObjectIterator objectiterator = this.entityMap.values().iterator();
+
+                        while (objectiterator.hasNext()) {
+                            ChunkMap.TrackedEntity playerchunkmap_entitytracker1 = (ChunkMap.TrackedEntity) objectiterator.next();
+
+                            if (playerchunkmap_entitytracker1.entity != entityplayer) {
+                                playerchunkmap_entitytracker1.updatePlayer(entityplayer);
                             }
                         }
                     }
@@ -953,105 +2029,216 @@
     }
 
     protected void removeEntity(Entity entity) {
+        org.spigotmc.AsyncCatcher.catchOp("entity untrack"); // Spigot
         if (entity instanceof ServerPlayer) {
-            ServerPlayer serverPlayer = (ServerPlayer)entity;
-            this.updatePlayerStatus(serverPlayer, false);
+            ServerPlayer entityplayer = (ServerPlayer) entity;
 
-            for(ChunkMap.TrackedEntity trackedEntity : this.entityMap.values()) {
-                trackedEntity.removePlayer(serverPlayer);
+            this.updatePlayerStatus(entityplayer, false);
+            ObjectIterator objectiterator = this.entityMap.values().iterator();
+
+            while (objectiterator.hasNext()) {
+                ChunkMap.TrackedEntity playerchunkmap_entitytracker = (ChunkMap.TrackedEntity) objectiterator.next();
+
+                playerchunkmap_entitytracker.removePlayer(entityplayer);
             }
         }
 
-        ChunkMap.TrackedEntity trackedEntity2 = this.entityMap.remove(entity.getId());
-        if (trackedEntity2 != null) {
-            trackedEntity2.broadcastRemoved();
+        ChunkMap.TrackedEntity playerchunkmap_entitytracker1 = (ChunkMap.TrackedEntity) this.entityMap.remove(entity.getId());
+
+        if (playerchunkmap_entitytracker1 != null) {
+            playerchunkmap_entitytracker1.broadcastRemoved();
         }
+        entity.tracker = null; // Paper - We're no longer tracked
+    }
+
+    // Paper start - optimised tracker
+    private final void processTrackQueue() {
+        this.level.timings.tracker1.startTiming();
+        try {
+            for (TrackedEntity tracker : this.entityMap.values()) {
+                // update tracker entry
+                tracker.updatePlayers(tracker.entity.getPlayersInTrackRange());
+            }
+        } finally {
+            this.level.timings.tracker1.stopTiming();
+        }
+
 
+        this.level.timings.tracker2.startTiming();
+        try {
+            for (TrackedEntity tracker : this.entityMap.values()) {
+                tracker.serverEntity.sendChanges();
+            }
+        } finally {
+            this.level.timings.tracker2.stopTiming();
+        }
     }
+    // Paper end - optimised tracker
 
     protected void tick() {
+        // Paper start - optimized tracker
+        if (true) {
+            this.processTrackQueue();
+            return;
+        }
+        // Paper end - optimized tracker
         List<ServerPlayer> list = Lists.newArrayList();
-        List<ServerPlayer> list2 = this.level.players();
+        List<ServerPlayer> list1 = this.level.players();
+
+        ChunkMap.TrackedEntity playerchunkmap_entitytracker;
+        ObjectIterator objectiterator;
+        level.timings.tracker1.startTiming(); // Paper
+
+        for (objectiterator = this.entityMap.values().iterator(); objectiterator.hasNext(); playerchunkmap_entitytracker.serverEntity.sendChanges()) {
+            playerchunkmap_entitytracker = (ChunkMap.TrackedEntity) objectiterator.next();
+            SectionPos sectionposition = playerchunkmap_entitytracker.lastSectionPos;
+            SectionPos sectionposition1 = SectionPos.of(playerchunkmap_entitytracker.entity);
+
+            if (!Objects.equals(sectionposition, sectionposition1)) {
+                playerchunkmap_entitytracker.updatePlayers(list1);
+                Entity entity = playerchunkmap_entitytracker.entity;
 
-        for(ChunkMap.TrackedEntity trackedEntity : this.entityMap.values()) {
-            SectionPos sectionPos = trackedEntity.lastSectionPos;
-            SectionPos sectionPos2 = SectionPos.of(trackedEntity.entity);
-            if (!Objects.equals(sectionPos, sectionPos2)) {
-                trackedEntity.updatePlayers(list2);
-                Entity entity = trackedEntity.entity;
                 if (entity instanceof ServerPlayer) {
-                    list.add((ServerPlayer)entity);
+                    list.add((ServerPlayer) entity);
                 }
 
-                trackedEntity.lastSectionPos = sectionPos2;
+                playerchunkmap_entitytracker.lastSectionPos = sectionposition1;
             }
-
-            trackedEntity.serverEntity.sendChanges();
         }
+        level.timings.tracker1.stopTiming(); // Paper
 
         if (!list.isEmpty()) {
-            for(ChunkMap.TrackedEntity trackedEntity2 : this.entityMap.values()) {
-                trackedEntity2.updatePlayers(list);
+            objectiterator = this.entityMap.values().iterator();
+
+            level.timings.tracker2.startTiming(); // Paper
+            while (objectiterator.hasNext()) {
+                playerchunkmap_entitytracker = (ChunkMap.TrackedEntity) objectiterator.next();
+                playerchunkmap_entitytracker.updatePlayers(list);
             }
+            level.timings.tracker2.stopTiming(); // Paper
         }
 
     }
 
     public void broadcast(Entity entity, Packet<?> packet) {
-        ChunkMap.TrackedEntity trackedEntity = this.entityMap.get(entity.getId());
-        if (trackedEntity != null) {
-            trackedEntity.broadcast(packet);
+        ChunkMap.TrackedEntity playerchunkmap_entitytracker = (ChunkMap.TrackedEntity) this.entityMap.get(entity.getId());
+
+        if (playerchunkmap_entitytracker != null) {
+            playerchunkmap_entitytracker.broadcast(packet);
         }
 
     }
 
     protected void broadcastAndSend(Entity entity, Packet<?> packet) {
-        ChunkMap.TrackedEntity trackedEntity = this.entityMap.get(entity.getId());
-        if (trackedEntity != null) {
-            trackedEntity.broadcastAndSend(packet);
+        ChunkMap.TrackedEntity playerchunkmap_entitytracker = (ChunkMap.TrackedEntity) this.entityMap.get(entity.getId());
+
+        if (playerchunkmap_entitytracker != null) {
+            playerchunkmap_entitytracker.broadcastAndSend(packet);
+        }
+
+    }
+
+    // Paper start
+    private static int getLightMask(final LevelChunk chunk) {
+        final net.minecraft.world.level.chunk.LevelChunkSection[] chunkSections = chunk.getSections();
+        int mask = 0;
+
+        for (int i = 0; i < chunkSections.length; ++i) {
+            /*
+
+
+Lightmasks have 18 bits, from the -1 (void) section until the 17th (air) section.
+Sections go from 0..16. Now whenever a section is not empty, it can potentially change lighting for the section itself, the section below and the section above, hence the bitmask 111b, which is 7d.
+
+             */
+            mask |= (net.minecraft.world.level.chunk.LevelChunkSection.isEmpty(chunkSections[i]) ? 0 : 7) << i;
         }
 
+        return mask;
+    }
+
+    private static int getCeilingLightMask(final LevelChunk chunk) {
+        int mask = getLightMask(chunk);
+
+        /*
+         It is similar to get highest bit, it would turn an 001010 into an 001111 so basically the highest bit and all below.
+         We then invert this, so we'd have 110000 and compare that to the "main" chunk.
+         This is because the bug only appears when the current chunks lightmaps are higher than those of the neighbors, thus we can omit sending neighbors which are lower than the current chunks lights.
+
+         so TLDR is that getCeilingLightMask returns a light mask with all bits set below the highest affected section. We could also count the number of leading zeros and invert them, somehow.
+         @TODO: Implement Leafs suggestion
+         either use Integer#numberOfLeadingZeros or document what this bithack is supposed to be doing then
+         */
+        mask |= mask >> 1;
+        mask |= mask >> 2;
+        mask |= mask >> 4;
+        mask |= mask >> 8;
+        mask |= mask >> 16;
+
+        return mask;
     }
+    // Paper end
 
     public void playerLoadedChunk(ServerPlayer player, Packet<?>[] packets, LevelChunk chunk) {
         if (packets[0] == null) {
-            packets[0] = new ClientboundLevelChunkPacket(chunk);
-            packets[1] = new ClientboundLightUpdatePacket(chunk.getPos(), this.lightEngine, (BitSet)null, (BitSet)null, true);
+            packets[0] = new ClientboundLevelChunkPacket(chunk, chunk.level.chunkPacketBlockController.shouldModify(player, chunk)); // Paper - Ani-Xray - Bypass
+            packets[1] = new ClientboundLightUpdatePacket(chunk.getPos(), this.lightEngine, (BitSet) null, (BitSet) null, true);
         }
 
         player.trackChunk(chunk.getPos(), packets[0], packets[1]);
         DebugPackets.sendPoiPacketsForChunk(this.level, chunk.getPos());
         List<Entity> list = Lists.newArrayList();
-        List<Entity> list2 = Lists.newArrayList();
+        List<Entity> list1 = Lists.newArrayList();
+        // Paper start - optimise entity tracker
+        // use the chunk entity list, not the whole trackedEntities map...
+        Entity[] entities = chunk.entities.getRawData();
+        for (int i = 0, size = chunk.entities.size(); i < size; ++i) {
+            Entity entity = entities[i];
+            if (entity == player) {
+                continue;
+            }
+            ChunkMap.TrackedEntity tracker = this.entityMap.get(entity.getId());
+            if (tracker != null) { // dumb plugins... move on...
+                tracker.updatePlayer(player);
+            }
 
-        for(ChunkMap.TrackedEntity trackedEntity : this.entityMap.values()) {
-            Entity entity = trackedEntity.entity;
-            if (entity != player && entity.chunkPosition().equals(chunk.getPos())) {
-                trackedEntity.updatePlayer(player);
-                if (entity instanceof Mob && ((Mob)entity).getLeashHolder() != null) {
-                    list.add(entity);
-                }
+            // keep the vanilla logic here - this is REQUIRED or else passengers and their vehicles disappear!
+            // (and god knows what the leash thing is)
 
-                if (!entity.getPassengers().isEmpty()) {
-                    list2.add(entity);
-                }
+            if (entity instanceof Mob && ((Mob)entity).getLeashHolder() != null) {
+                list.add(entity);
+            }
+
+            if (!entity.getPassengers().isEmpty()) {
+                list1.add(entity);
             }
         }
+        // Paper end - optimise entity tracker
+
+        Iterator iterator;
+        Entity entity1;
 
         if (!list.isEmpty()) {
-            for(Entity entity2 : list) {
-                player.connection.send(new ClientboundSetEntityLinkPacket(entity2, ((Mob)entity2).getLeashHolder()));
+            iterator = list.iterator();
+
+            while (iterator.hasNext()) {
+                entity1 = (Entity) iterator.next();
+                player.connection.send(new ClientboundSetEntityLinkPacket(entity1, ((Mob) entity1).getLeashHolder()));
             }
         }
 
-        if (!list2.isEmpty()) {
-            for(Entity entity3 : list2) {
-                player.connection.send(new ClientboundSetPassengersPacket(entity3));
+        if (!list1.isEmpty()) {
+            iterator = list1.iterator();
+
+            while (iterator.hasNext()) {
+                entity1 = (Entity) iterator.next();
+                player.connection.send(new ClientboundSetPassengersPacket(entity1));
             }
         }
 
     }
 
+    @Deprecated public PoiManager getVillagePlace() { return this.getPoiManager(); } // Paper - OBFHELPER
     protected PoiManager getPoiManager() {
         return this.poiManager;
     }
@@ -1066,13 +2253,14 @@
         });
     }
 
-    void onFullChunkStatusChange(ChunkPos chunkPos, ChunkHolder.FullChunkStatus fullChunkStatus) {
-        this.chunkStatusListener.onChunkStatusChange(chunkPos, fullChunkStatus);
+    void onFullChunkStatusChange(ChunkPos chunkcoordintpair, ChunkHolder.FullChunkStatus playerchunk_state) {
+        this.chunkStatusListener.onChunkStatusChange(chunkcoordintpair, playerchunk_state);
     }
 
-    class DistanceManager extends net.minecraft.server.level.DistanceManager {
-        protected DistanceManager(Executor mainThreadExecutor, Executor executor) {
-            super(mainThreadExecutor, executor);
+    public class ChunkDistanceManager extends DistanceManager {
+
+        protected ChunkDistanceManager(Executor workerExecutor, Executor mainThreadExecutor) {
+            super(workerExecutor, mainThreadExecutor);
         }
 
         @Override
@@ -1088,42 +2276,77 @@
 
         @Nullable
         @Override
-        protected ChunkHolder updateChunkScheduling(long pos, int level, @Nullable ChunkHolder holder, int i) {
-            return ChunkMap.this.updateChunkScheduling(pos, level, holder, i);
+        protected ChunkHolder updateChunkScheduling(long pos, int level, @Nullable ChunkHolder holder, int k) {
+            return ChunkMap.this.updateChunkScheduling(pos, level, holder, k);
         }
     }
 
     public class TrackedEntity {
+
         final ServerEntity serverEntity;
         final Entity entity;
         private final int range;
         SectionPos lastSectionPos;
-        public final Set<ServerPlayerConnection> seenBy = Sets.newIdentityHashSet();
+        public final Set<ServerPlayerConnection> seenBy = new ReferenceOpenHashSet<>(); // Paper - optimise map impl
 
-        public TrackedEntity(Entity entity, int maxDistance, int tickInterval, boolean alwaysUpdateVelocity) {
-            this.serverEntity = new ServerEntity(ChunkMap.this.level, entity, tickInterval, alwaysUpdateVelocity, this::broadcast);
+        public TrackedEntity(Entity entity, int i, int j, boolean flag) {
+            this.serverEntity = new ServerEntity(ChunkMap.this.level, entity, j, flag, this::broadcast, this.seenBy); // CraftBukkit
             this.entity = entity;
-            this.range = maxDistance;
+            this.range = i;
             this.lastSectionPos = SectionPos.of(entity);
         }
 
-        @Override
-        public boolean equals(Object object) {
-            if (object instanceof ChunkMap.TrackedEntity) {
-                return ((ChunkMap.TrackedEntity)object).entity.getId() == this.entity.getId();
-            } else {
-                return false;
+        // Paper start - use distance map to optimise tracker
+        com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> lastTrackerCandidates;
+
+        final void updatePlayers(com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newTrackerCandidates) {
+            com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> oldTrackerCandidates = this.lastTrackerCandidates;
+            this.lastTrackerCandidates = newTrackerCandidates;
+
+            if (newTrackerCandidates != null) {
+                Object[] rawData = newTrackerCandidates.getBackingSet();
+                for (int i = 0, len = rawData.length; i < len; ++i) {
+                    Object raw = rawData[i];
+                    if (!(raw instanceof ServerPlayer)) {
+                        continue;
+                    }
+                    ServerPlayer player = (ServerPlayer)raw;
+                    this.updatePlayer(player);
+                }
+            }
+
+            if (oldTrackerCandidates == newTrackerCandidates) {
+                // this is likely the case.
+                // means there has been no range changes, so we can just use the above for tracking.
+                return;
+            }
+
+            // stuff could have been removed, so we need to check the trackedPlayers set
+            // for players that were removed
+
+            for (ServerPlayerConnection conn : this.seenBy.toArray(new ServerPlayerConnection[0])) { // avoid CME
+                if (newTrackerCandidates == null || !newTrackerCandidates.contains(conn.getPlayer())) {
+                    this.updatePlayer(conn.getPlayer());
+                }
             }
         }
+        // Paper end - use distance map to optimise tracker
+
+        public boolean equals(Object object) {
+            return object instanceof ChunkMap.TrackedEntity ? ((ChunkMap.TrackedEntity) object).entity.getId() == this.entity.getId() : false;
+        }
 
-        @Override
         public int hashCode() {
             return this.entity.getId();
         }
 
         public void broadcast(Packet<?> packet) {
-            for(ServerPlayerConnection serverPlayerConnection : this.seenBy) {
-                serverPlayerConnection.send(packet);
+            Iterator iterator = this.seenBy.iterator();
+
+            while (iterator.hasNext()) {
+                ServerPlayerConnection serverplayerconnection = (ServerPlayerConnection) iterator.next();
+
+                serverplayerconnection.send(packet);
             }
 
         }
@@ -1131,19 +2354,24 @@
         public void broadcastAndSend(Packet<?> packet) {
             this.broadcast(packet);
             if (this.entity instanceof ServerPlayer) {
-                ((ServerPlayer)this.entity).connection.send(packet);
+                ((ServerPlayer) this.entity).connection.send(packet);
             }
 
         }
 
         public void broadcastRemoved() {
-            for(ServerPlayerConnection serverPlayerConnection : this.seenBy) {
-                this.serverEntity.removePairing(serverPlayerConnection.getPlayer());
+            Iterator iterator = this.seenBy.iterator();
+
+            while (iterator.hasNext()) {
+                ServerPlayerConnection serverplayerconnection = (ServerPlayerConnection) iterator.next();
+
+                this.serverEntity.removePairing(serverplayerconnection.getPlayer());
             }
 
         }
 
         public void removePlayer(ServerPlayer player) {
+            org.spigotmc.AsyncCatcher.catchOp("player tracker clear"); // Spigot
             if (this.seenBy.remove(player.connection)) {
                 this.serverEntity.removePairing(player);
             }
@@ -1151,11 +2379,26 @@
         }
 
         public void updatePlayer(ServerPlayer player) {
+            org.spigotmc.AsyncCatcher.catchOp("player tracker update"); // Spigot
             if (player != this.entity) {
-                Vec3 vec3 = player.position().subtract(this.serverEntity.sentPos());
-                int i = Math.min(this.getEffectiveRange(), (ChunkMap.this.viewDistance - 1) * 16);
-                boolean bl = vec3.x >= (double)(-i) && vec3.x <= (double)i && vec3.z >= (double)(-i) && vec3.z <= (double)i && this.entity.broadcastToPlayer(player);
-                if (bl) {
+                // Paper start - remove allocation of Vec3D here
+                //Vec3D vec3d = entityplayer.getPositionVector().d(this.tracker.getPositionVector()); // MC-155077, SPIGOT-5113
+                double vec3d_dx = player.getX() - this.entity.getX();
+                double vec3d_dy = player.getY() - this.entity.getY();
+                double vec3d_dz = player.getZ() - this.entity.getZ();
+                // Paper end - remove allocation of Vec3D here
+                int i = Math.min(this.getEffectiveRange(), player.getBukkitEntity().getViewDistance() * 16); // Paper - per player view distance
+                boolean flag = vec3d_dx >= (double) (-i) && vec3d_dx <= (double) i && vec3d_dz >= (double) (-i) && vec3d_dz <= (double) i && this.entity.broadcastToPlayer(player); // Paper - remove allocation of Vec3D here
+
+                // CraftBukkit start - respect vanish API
+                if (this.entity instanceof ServerPlayer) {
+                    Player player1 = ((ServerPlayer) this.entity).getBukkitEntity();
+                    if (!player.getBukkitEntity().canSee(player1)) {
+                        flag = false;
+                    }
+                }
+                // CraftBukkit end
+                if (flag) {
                     if (this.seenBy.add(player.connection)) {
                         this.serverEntity.addPairing(player);
                     }
@@ -1172,9 +2415,13 @@
 
         private int getEffectiveRange() {
             int i = this.range;
+            Iterator iterator = this.entity.getIndirectPassengers().iterator();
 
-            for(Entity entity : this.entity.getIndirectPassengers()) {
+            while (iterator.hasNext()) {
+                Entity entity = (Entity) iterator.next();
                 int j = entity.getType().clientTrackingRange() * 16;
+                j = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, j); // Paper
+
                 if (j > i) {
                     i = j;
                 }
@@ -1184,8 +2431,12 @@
         }
 
         public void updatePlayers(List<ServerPlayer> players) {
-            for(ServerPlayer serverPlayer : players) {
-                this.updatePlayer(serverPlayer);
+            Iterator iterator = players.iterator();
+
+            while (iterator.hasNext()) {
+                ServerPlayer entityplayer = (ServerPlayer) iterator.next();
+
+                this.updatePlayer(entityplayer);
             }
 
         }
