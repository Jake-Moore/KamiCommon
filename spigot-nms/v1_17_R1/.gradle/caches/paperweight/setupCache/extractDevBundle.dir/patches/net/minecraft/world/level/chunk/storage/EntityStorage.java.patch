--- a/net/minecraft/world/level/chunk/storage/EntityStorage.java
+++ b/net/minecraft/world/level/chunk/storage/EntityStorage.java
@@ -10,6 +10,7 @@
 import java.util.Objects;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
+import java.util.function.Function;
 import net.minecraft.SharedConstants;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.IntArrayTag;
@@ -21,19 +22,21 @@
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.Level;
 import net.minecraft.world.level.entity.ChunkEntities;
 import net.minecraft.world.level.entity.EntityPersistentStorage;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 public class EntityStorage implements EntityPersistentStorage<Entity> {
+
     private static final Logger LOGGER = LogManager.getLogger();
     private static final String ENTITIES_TAG = "Entities";
     private static final String POSITION_TAG = "Position";
-    public final ServerLevel level;
+    public final ServerLevel level; // PAIL private -> public
     private final IOWorker worker;
     private final LongSet emptyChunks = new LongOpenHashSet();
-    private final ProcessorMailbox<Runnable> entityDeserializerQueue;
+    public final ProcessorMailbox<Runnable> entityDeserializerQueue; // PAIL private -> public
     protected final DataFixer fixerUpper;
 
     public EntityStorage(ServerLevel world, File chunkFile, DataFixer dataFixer, boolean dsync, Executor executor) {
@@ -45,31 +48,43 @@
 
     @Override
     public CompletableFuture<ChunkEntities<Entity>> loadEntities(ChunkPos pos) {
-        return this.emptyChunks.contains(pos.toLong()) ? CompletableFuture.completedFuture(emptyChunk(pos)) : this.worker.loadAsync(pos).thenApplyAsync((compound) -> {
-            if (compound == null) {
-                this.emptyChunks.add(pos.toLong());
-                return emptyChunk(pos);
-            } else {
-                try {
-                    ChunkPos chunkPos2 = readChunkPos(compound);
-                    if (!Objects.equals(pos, chunkPos2)) {
-                        LOGGER.error("Chunk file at {} is in the wrong location. (Expected {}, got {})", pos, pos, chunkPos2);
+        if (this.emptyChunks.contains(pos.toLong())) {
+            return CompletableFuture.completedFuture(EntityStorage.emptyChunk(pos));
+        } else {
+            CompletableFuture<CompoundTag> completablefuture = this.worker.loadAsync(pos); // CraftBukkit - decompile error
+            Function<CompoundTag, ChunkEntities<Entity>> function = (nbttagcompound) -> { // CraftBukkit - decompile error
+                if (nbttagcompound == null) {
+                    this.emptyChunks.add(pos.toLong());
+                    return EntityStorage.emptyChunk(pos);
+                } else {
+                    try {
+                        ChunkPos chunkcoordintpair1 = EntityStorage.readChunkPos(nbttagcompound);
+
+                        if (!Objects.equals(pos, chunkcoordintpair1)) {
+                            EntityStorage.LOGGER.error("Chunk file at {} is in the wrong location. (Expected {}, got {})", pos, pos, chunkcoordintpair1);
+                        }
+                    } catch (Exception exception) {
+                        EntityStorage.LOGGER.warn("Failed to parse chunk {} position info", pos, exception);
                     }
-                } catch (Exception var6) {
-                    LOGGER.warn("Failed to parse chunk {} position info", pos, var6);
+
+                    CompoundTag nbttagcompound1 = this.upgradeChunkTag(nbttagcompound);
+                    ListTag nbttaglist = nbttagcompound1.getList("Entities", 10);
+                    List<Entity> list = (List) EntityType.loadEntitiesRecursive((List) nbttaglist, (Level) this.level).collect(ImmutableList.toImmutableList());
+
+                    return new ChunkEntities<>(pos, list);
                 }
+            };
+            ProcessorMailbox threadedmailbox = this.entityDeserializerQueue;
 
-                CompoundTag compoundTag = this.upgradeChunkTag(compound);
-                ListTag listTag = compoundTag.getList("Entities", 10);
-                List<Entity> list = EntityType.loadEntitiesRecursive(listTag, this.level).collect(ImmutableList.toImmutableList());
-                return new ChunkEntities<>(pos, list);
-            }
-        }, this.entityDeserializerQueue::tell);
+            Objects.requireNonNull(this.entityDeserializerQueue);
+            return completablefuture.thenApplyAsync(function, threadedmailbox::tell);
+        }
     }
 
     private static ChunkPos readChunkPos(CompoundTag chunkTag) {
-        int[] is = chunkTag.getIntArray("Position");
-        return new ChunkPos(is[0], is[1]);
+        int[] aint = chunkTag.getIntArray("Position");
+
+        return new ChunkPos(aint[0], aint[1]);
     }
 
     private static void writeChunkPos(CompoundTag chunkTag, ChunkPos pos) {
@@ -82,30 +97,45 @@
 
     @Override
     public void storeEntities(ChunkEntities<Entity> dataList) {
-        ChunkPos chunkPos = dataList.getPos();
+        ChunkPos chunkcoordintpair = dataList.getPos();
+
         if (dataList.isEmpty()) {
-            if (this.emptyChunks.add(chunkPos.toLong())) {
-                this.worker.store(chunkPos, (CompoundTag)null);
+            if (this.emptyChunks.add(chunkcoordintpair.toLong())) {
+                this.worker.store(chunkcoordintpair, (CompoundTag) null);
             }
 
         } else {
-            ListTag listTag = new ListTag();
+            ListTag nbttaglist = new ListTag();
+
+            final java.util.Map<net.minecraft.world.entity.EntityType<?>, Integer> savedEntityCounts = new java.util.HashMap<>(); // Paper
             dataList.getEntities().forEach((entity) -> {
-                CompoundTag compoundTag = new CompoundTag();
-                if (entity.save(compoundTag)) {
-                    listTag.add(compoundTag);
+                // Paper start
+                final EntityType<?> entityType = entity.getType();
+                final int saveLimit = this.level.paperConfig.entityPerChunkSaveLimits.getOrDefault(entityType, -1);
+                if (saveLimit > -1) {
+                    if (savedEntityCounts.getOrDefault(entityType, 0) >= saveLimit) {
+                        return;
+                    }
+                    savedEntityCounts.merge(entityType, 1, Integer::sum);
+                }
+                // Paper end
+                CompoundTag nbttagcompound = new CompoundTag();
+
+                if (entity.save(nbttagcompound)) {
+                    nbttaglist.add(nbttagcompound);
                 }
 
             });
-            CompoundTag compoundTag = new CompoundTag();
-            compoundTag.putInt("DataVersion", SharedConstants.getCurrentVersion().getWorldVersion());
-            compoundTag.put("Entities", listTag);
-            writeChunkPos(compoundTag, chunkPos);
-            this.worker.store(chunkPos, compoundTag).exceptionally((ex) -> {
-                LOGGER.error("Failed to store chunk {}", chunkPos, ex);
+            CompoundTag nbttagcompound = new CompoundTag();
+
+            nbttagcompound.putInt("DataVersion", SharedConstants.getCurrentVersion().getWorldVersion());
+            nbttagcompound.put("Entities", nbttaglist);
+            EntityStorage.writeChunkPos(nbttagcompound, chunkcoordintpair);
+            this.worker.store(chunkcoordintpair, nbttagcompound).exceptionally((throwable) -> {
+                EntityStorage.LOGGER.error("Failed to store chunk {}", chunkcoordintpair, throwable);
                 return null;
             });
-            this.emptyChunks.remove(chunkPos.toLong());
+            this.emptyChunks.remove(chunkcoordintpair.toLong());
         }
     }
 
@@ -116,8 +146,9 @@
     }
 
     private CompoundTag upgradeChunkTag(CompoundTag chunkTag) {
-        int i = getVersion(chunkTag);
-        return NbtUtils.update(this.fixerUpper, DataFixTypes.ENTITY_CHUNK, chunkTag, i);
+        int i = EntityStorage.getVersion(chunkTag);
+
+        return ca.spottedleaf.dataconverter.minecraft.MCDataConverter.convertTag(ca.spottedleaf.dataconverter.minecraft.datatypes.MCTypeRegistry.ENTITY_CHUNK, chunkTag, i, SharedConstants.getCurrentVersion().getWorldVersion()); // Paper - route to new converter system
     }
 
     public static int getVersion(CompoundTag chunkTag) {
