--- a/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
+++ b/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
@@ -4,7 +4,10 @@
 import com.google.common.collect.Sets;
 import com.mojang.serialization.Codec;
 import com.mojang.serialization.codecs.RecordCodecBuilder;
+import java.util.HashSet;
+import java.util.Iterator;
 import java.util.List;
+import java.util.Objects;
 import java.util.OptionalInt;
 import java.util.Random;
 import java.util.Set;
@@ -29,6 +32,7 @@
 import net.minecraft.world.level.LevelHeightAccessor;
 import net.minecraft.world.level.NaturalSpawner;
 import net.minecraft.world.level.NoiseColumn;
+import net.minecraft.world.level.ServerLevelAccessor;
 import net.minecraft.world.level.StructureFeatureManager;
 import net.minecraft.world.level.biome.Biome;
 import net.minecraft.world.level.biome.BiomeSource;
@@ -48,13 +52,14 @@
 import net.minecraft.world.level.levelgen.synth.SurfaceNoise;
 
 public final class NoiseBasedChunkGenerator extends ChunkGenerator {
+
     public static final Codec<NoiseBasedChunkGenerator> CODEC = RecordCodecBuilder.create((instance) -> {
-        return instance.group(BiomeSource.CODEC.fieldOf("biome_source").forGetter((noiseBasedChunkGenerator) -> {
-            return noiseBasedChunkGenerator.biomeSource;
-        }), Codec.LONG.fieldOf("seed").stable().forGetter((noiseBasedChunkGenerator) -> {
-            return noiseBasedChunkGenerator.seed;
-        }), NoiseGeneratorSettings.CODEC.fieldOf("settings").forGetter((noiseBasedChunkGenerator) -> {
-            return noiseBasedChunkGenerator.settings;
+        return instance.group(BiomeSource.CODEC.fieldOf("biome_source").forGetter((chunkgeneratorabstract) -> {
+            return chunkgeneratorabstract.biomeSource;
+        }), Codec.LONG.fieldOf("seed").stable().forGetter((chunkgeneratorabstract) -> {
+            return chunkgeneratorabstract.seed;
+        }), NoiseGeneratorSettings.CODEC.fieldOf("settings").forGetter((chunkgeneratorabstract) -> {
+            return chunkgeneratorabstract.settings;
         })).apply(instance, instance.stable(NoiseBasedChunkGenerator::new));
     });
     private static final BlockState AIR = Blocks.AIR.defaultBlockState();
@@ -71,7 +76,7 @@
     protected final BlockState defaultBlock;
     protected final BlockState defaultFluid;
     private final long seed;
-    protected final Supplier<NoiseGeneratorSettings> settings;
+    public final Supplier<NoiseGeneratorSettings> settings; // PAIL protected -> public
     private final int height;
     private final NoiseSampler sampler;
     private final BaseStoneSource baseStoneSource;
@@ -83,56 +88,62 @@
     }
 
     private NoiseBasedChunkGenerator(BiomeSource populationSource, BiomeSource biomeSource, long seed, Supplier<NoiseGeneratorSettings> settings) {
-        super(populationSource, biomeSource, settings.get().structureSettings(), seed);
+        super(populationSource, biomeSource, ((NoiseGeneratorSettings) settings.get()).structureSettings(), seed);
         this.seed = seed;
-        NoiseGeneratorSettings noiseGeneratorSettings = settings.get();
+        NoiseGeneratorSettings generatorsettingbase = (NoiseGeneratorSettings) settings.get();
+
         this.settings = settings;
-        NoiseSettings noiseSettings = noiseGeneratorSettings.noiseSettings();
-        this.height = noiseSettings.height();
-        this.cellHeight = QuartPos.toBlock(noiseSettings.noiseSizeVertical());
-        this.cellWidth = QuartPos.toBlock(noiseSettings.noiseSizeHorizontal());
-        this.defaultBlock = noiseGeneratorSettings.getDefaultBlock();
-        this.defaultFluid = noiseGeneratorSettings.getDefaultFluid();
+        NoiseSettings noisesettings = generatorsettingbase.noiseSettings();
+
+        this.height = noisesettings.height();
+        this.cellHeight = QuartPos.toBlock(noisesettings.noiseSizeVertical());
+        this.cellWidth = QuartPos.toBlock(noisesettings.noiseSizeHorizontal());
+        this.defaultBlock = generatorsettingbase.getDefaultBlock();
+        this.defaultFluid = generatorsettingbase.getDefaultFluid();
         this.cellCountX = 16 / this.cellWidth;
-        this.cellCountY = noiseSettings.height() / this.cellHeight;
+        this.cellCountY = noisesettings.height() / this.cellHeight;
         this.cellCountZ = 16 / this.cellWidth;
-        WorldgenRandom worldgenRandom = new WorldgenRandom(seed);
-        BlendedNoise blendedNoise = new BlendedNoise(worldgenRandom);
-        this.surfaceNoise = (SurfaceNoise)(noiseSettings.useSimplexSurfaceNoise() ? new PerlinSimplexNoise(worldgenRandom, IntStream.rangeClosed(-3, 0)) : new PerlinNoise(worldgenRandom, IntStream.rangeClosed(-3, 0)));
-        worldgenRandom.consumeCount(2620);
-        PerlinNoise perlinNoise = new PerlinNoise(worldgenRandom, IntStream.rangeClosed(-15, 0));
-        SimplexNoise simplexNoise;
-        if (noiseSettings.islandNoiseOverride()) {
-            WorldgenRandom worldgenRandom2 = new WorldgenRandom(seed);
-            worldgenRandom2.consumeCount(17292);
-            simplexNoise = new SimplexNoise(worldgenRandom2);
+        WorldgenRandom seededrandom = new WorldgenRandom(seed);
+        BlendedNoise blendednoise = new BlendedNoise(seededrandom);
+
+        this.surfaceNoise = (SurfaceNoise) (noisesettings.useSimplexSurfaceNoise() ? new PerlinSimplexNoise(seededrandom, IntStream.rangeClosed(-3, 0)) : new PerlinNoise(seededrandom, IntStream.rangeClosed(-3, 0)));
+        seededrandom.consumeCount(2620);
+        PerlinNoise noisegeneratoroctaves = new PerlinNoise(seededrandom, IntStream.rangeClosed(-15, 0));
+        SimplexNoise noisegenerator3handler;
+
+        if (noisesettings.islandNoiseOverride()) {
+            WorldgenRandom seededrandom1 = new WorldgenRandom(seed);
+
+            seededrandom1.consumeCount(17292);
+            noisegenerator3handler = new SimplexNoise(seededrandom1);
         } else {
-            simplexNoise = null;
+            noisegenerator3handler = null;
         }
 
-        this.barrierNoise = NormalNoise.create(new SimpleRandomSource(worldgenRandom.nextLong()), -3, 1.0D);
-        this.waterLevelNoise = NormalNoise.create(new SimpleRandomSource(worldgenRandom.nextLong()), -3, 1.0D, 0.0D, 2.0D);
-        this.lavaNoise = NormalNoise.create(new SimpleRandomSource(worldgenRandom.nextLong()), -1, 1.0D, 0.0D);
-        NoiseModifier noiseModifier;
-        if (noiseGeneratorSettings.isNoiseCavesEnabled()) {
-            noiseModifier = new Cavifier(worldgenRandom, noiseSettings.minY() / this.cellHeight);
+        this.barrierNoise = NormalNoise.create(new SimpleRandomSource(seededrandom.nextLong()), -3, 1.0D);
+        this.waterLevelNoise = NormalNoise.create(new SimpleRandomSource(seededrandom.nextLong()), -3, 1.0D, 0.0D, 2.0D);
+        this.lavaNoise = NormalNoise.create(new SimpleRandomSource(seededrandom.nextLong()), -1, 1.0D, 0.0D);
+        Object object;
+
+        if (generatorsettingbase.isNoiseCavesEnabled()) {
+            object = new Cavifier(seededrandom, noisesettings.minY() / this.cellHeight);
         } else {
-            noiseModifier = NoiseModifier.PASSTHROUGH;
+            object = NoiseModifier.PASSTHROUGH;
         }
 
-        this.sampler = new NoiseSampler(populationSource, this.cellWidth, this.cellHeight, this.cellCountY, noiseSettings, blendedNoise, simplexNoise, perlinNoise, noiseModifier);
-        this.baseStoneSource = new DepthBasedReplacingBaseStoneSource(seed, this.defaultBlock, Blocks.DEEPSLATE.defaultBlockState(), noiseGeneratorSettings);
-        this.oreVeinifier = new OreVeinifier(seed, this.defaultBlock, this.cellWidth, this.cellHeight, noiseGeneratorSettings.noiseSettings().minY());
+        this.sampler = new NoiseSampler(populationSource, this.cellWidth, this.cellHeight, this.cellCountY, noisesettings, blendednoise, noisegenerator3handler, noisegeneratoroctaves, (NoiseModifier) object);
+        this.baseStoneSource = new DepthBasedReplacingBaseStoneSource(seed, this.defaultBlock, Blocks.DEEPSLATE.defaultBlockState(), generatorsettingbase);
+        this.oreVeinifier = new OreVeinifier(seed, this.defaultBlock, this.cellWidth, this.cellHeight, generatorsettingbase.noiseSettings().minY());
         this.noodleCavifier = new NoodleCavifier(seed);
     }
 
     private boolean isAquifersEnabled() {
-        return this.settings.get().isAquifersEnabled();
+        return ((NoiseGeneratorSettings) this.settings.get()).isAquifersEnabled();
     }
 
     @Override
     protected Codec<? extends ChunkGenerator> codec() {
-        return CODEC;
+        return NoiseBasedChunkGenerator.CODEC;
     }
 
     @Override
@@ -141,41 +152,46 @@
     }
 
     public boolean stable(long seed, ResourceKey<NoiseGeneratorSettings> settingsKey) {
-        return this.seed == seed && this.settings.get().stable(settingsKey);
+        return this.seed == seed && ((NoiseGeneratorSettings) this.settings.get()).stable(settingsKey);
     }
 
     private double[] makeAndFillNoiseColumn(int x, int z, int minY, int noiseSizeY) {
-        double[] ds = new double[noiseSizeY + 1];
-        this.fillNoiseColumn(ds, x, z, minY, noiseSizeY);
-        return ds;
+        double[] adouble = new double[noiseSizeY + 1];
+
+        this.fillNoiseColumn(adouble, x, z, minY, noiseSizeY);
+        return adouble;
     }
 
     private void fillNoiseColumn(double[] buffer, int x, int z, int minY, int noiseSizeY) {
-        NoiseSettings noiseSettings = this.settings.get().noiseSettings();
-        this.sampler.fillNoiseColumn(buffer, x, z, noiseSettings, this.getSeaLevel(), minY, noiseSizeY);
+        NoiseSettings noisesettings = ((NoiseGeneratorSettings) this.settings.get()).noiseSettings();
+
+        this.sampler.fillNoiseColumn(buffer, x, z, noisesettings, this.getSeaLevel(), minY, noiseSizeY);
     }
 
     @Override
     public int getBaseHeight(int x, int z, Heightmap.Types heightmap, LevelHeightAccessor world) {
-        int i = Math.max(this.settings.get().noiseSettings().minY(), world.getMinBuildHeight());
-        int j = Math.min(this.settings.get().noiseSettings().minY() + this.settings.get().noiseSettings().height(), world.getMaxBuildHeight());
-        int k = Mth.intFloorDiv(i, this.cellHeight);
-        int l = Mth.intFloorDiv(j - i, this.cellHeight);
-        return l <= 0 ? world.getMinBuildHeight() : this.iterateNoiseColumn(x, z, (BlockState[])null, heightmap.isOpaque(), k, l).orElse(world.getMinBuildHeight());
+        int k = Math.max(((NoiseGeneratorSettings) this.settings.get()).noiseSettings().minY(), world.getMinBuildHeight());
+        int l = Math.min(((NoiseGeneratorSettings) this.settings.get()).noiseSettings().minY() + ((NoiseGeneratorSettings) this.settings.get()).noiseSettings().height(), world.getMaxBuildHeight());
+        int i1 = Mth.intFloorDiv(k, this.cellHeight);
+        int j1 = Mth.intFloorDiv(l - k, this.cellHeight);
+
+        return j1 <= 0 ? world.getMinBuildHeight() : this.iterateNoiseColumn(x, z, (BlockState[]) null, heightmap.isOpaque(), i1, j1).orElse(world.getMinBuildHeight());
     }
 
     @Override
     public NoiseColumn getBaseColumn(int x, int z, LevelHeightAccessor world) {
-        int i = Math.max(this.settings.get().noiseSettings().minY(), world.getMinBuildHeight());
-        int j = Math.min(this.settings.get().noiseSettings().minY() + this.settings.get().noiseSettings().height(), world.getMaxBuildHeight());
-        int k = Mth.intFloorDiv(i, this.cellHeight);
-        int l = Mth.intFloorDiv(j - i, this.cellHeight);
-        if (l <= 0) {
-            return new NoiseColumn(i, EMPTY_COLUMN);
+        int k = Math.max(((NoiseGeneratorSettings) this.settings.get()).noiseSettings().minY(), world.getMinBuildHeight());
+        int l = Math.min(((NoiseGeneratorSettings) this.settings.get()).noiseSettings().minY() + ((NoiseGeneratorSettings) this.settings.get()).noiseSettings().height(), world.getMaxBuildHeight());
+        int i1 = Mth.intFloorDiv(k, this.cellHeight);
+        int j1 = Mth.intFloorDiv(l - k, this.cellHeight);
+
+        if (j1 <= 0) {
+            return new NoiseColumn(k, NoiseBasedChunkGenerator.EMPTY_COLUMN);
         } else {
-            BlockState[] blockStates = new BlockState[l * this.cellHeight];
-            this.iterateNoiseColumn(x, z, blockStates, (Predicate<BlockState>)null, k, l);
-            return new NoiseColumn(i, blockStates);
+            BlockState[] aiblockdata = new BlockState[j1 * this.cellHeight];
+
+            this.iterateNoiseColumn(x, z, aiblockdata, (Predicate) null, i1, j1);
+            return new NoiseColumn(k, aiblockdata);
         }
     }
 
@@ -185,39 +201,40 @@
     }
 
     private OptionalInt iterateNoiseColumn(int x, int z, @Nullable BlockState[] states, @Nullable Predicate<BlockState> predicate, int minY, int noiseSizeY) {
-        int i = SectionPos.blockToSectionCoord(x);
-        int j = SectionPos.blockToSectionCoord(z);
-        int k = Math.floorDiv(x, this.cellWidth);
-        int l = Math.floorDiv(z, this.cellWidth);
-        int m = Math.floorMod(x, this.cellWidth);
-        int n = Math.floorMod(z, this.cellWidth);
-        double d = (double)m / (double)this.cellWidth;
-        double e = (double)n / (double)this.cellWidth;
-        double[][] ds = new double[][]{this.makeAndFillNoiseColumn(k, l, minY, noiseSizeY), this.makeAndFillNoiseColumn(k, l + 1, minY, noiseSizeY), this.makeAndFillNoiseColumn(k + 1, l, minY, noiseSizeY), this.makeAndFillNoiseColumn(k + 1, l + 1, minY, noiseSizeY)};
-        Aquifer aquifer = this.getAquifer(minY, noiseSizeY, new ChunkPos(i, j));
+        int i1 = SectionPos.blockToSectionCoord(x);
+        int j1 = SectionPos.blockToSectionCoord(z);
+        int k1 = Math.floorDiv(x, this.cellWidth);
+        int l1 = Math.floorDiv(z, this.cellWidth);
+        int i2 = Math.floorMod(x, this.cellWidth);
+        int j2 = Math.floorMod(z, this.cellWidth);
+        double d0 = (double) i2 / (double) this.cellWidth;
+        double d1 = (double) j2 / (double) this.cellWidth;
+        double[][] adouble = new double[][]{this.makeAndFillNoiseColumn(k1, l1, minY, noiseSizeY), this.makeAndFillNoiseColumn(k1, l1 + 1, minY, noiseSizeY), this.makeAndFillNoiseColumn(k1 + 1, l1, minY, noiseSizeY), this.makeAndFillNoiseColumn(k1 + 1, l1 + 1, minY, noiseSizeY)};
+        Aquifer aquifer = this.getAquifer(minY, noiseSizeY, new ChunkPos(i1, j1));
 
-        for(int o = noiseSizeY - 1; o >= 0; --o) {
-            double f = ds[0][o];
-            double g = ds[1][o];
-            double h = ds[2][o];
-            double p = ds[3][o];
-            double q = ds[0][o + 1];
-            double r = ds[1][o + 1];
-            double s = ds[2][o + 1];
-            double t = ds[3][o + 1];
+        for (int k2 = noiseSizeY - 1; k2 >= 0; --k2) {
+            double d2 = adouble[0][k2];
+            double d3 = adouble[1][k2];
+            double d4 = adouble[2][k2];
+            double d5 = adouble[3][k2];
+            double d6 = adouble[0][k2 + 1];
+            double d7 = adouble[1][k2 + 1];
+            double d8 = adouble[2][k2 + 1];
+            double d9 = adouble[3][k2 + 1];
+
+            for (int l2 = this.cellHeight - 1; l2 >= 0; --l2) {
+                double d10 = (double) l2 / (double) this.cellHeight;
+                double d11 = Mth.lerp3(d10, d0, d1, d2, d6, d4, d8, d3, d7, d5, d9);
+                int i3 = k2 * this.cellHeight + l2;
+                int j3 = i3 + minY * this.cellHeight;
+                BlockState iblockdata = this.updateNoiseAndGenerateBaseState(Beardifier.NO_BEARDS, aquifer, this.baseStoneSource, NoiseModifier.PASSTHROUGH, x, j3, z, d11);
 
-            for(int u = this.cellHeight - 1; u >= 0; --u) {
-                double v = (double)u / (double)this.cellHeight;
-                double w = Mth.lerp3(v, d, e, f, q, h, s, g, r, p, t);
-                int y = o * this.cellHeight + u;
-                int aa = y + minY * this.cellHeight;
-                BlockState blockState = this.updateNoiseAndGenerateBaseState(Beardifier.NO_BEARDS, aquifer, this.baseStoneSource, NoiseModifier.PASSTHROUGH, x, aa, z, w);
                 if (states != null) {
-                    states[y] = blockState;
+                    states[i3] = iblockdata;
                 }
 
-                if (predicate != null && predicate.test(blockState)) {
-                    return OptionalInt.of(aa + 1);
+                if (predicate != null && predicate.test(iblockdata)) {
+                    return OptionalInt.of(j3 + 1);
                 }
             }
         }
@@ -226,71 +243,96 @@
     }
 
     private Aquifer getAquifer(int startY, int deltaY, ChunkPos pos) {
-        return !this.isAquifersEnabled() ? Aquifer.createDisabled(this.getSeaLevel(), this.defaultFluid) : Aquifer.create(pos, this.barrierNoise, this.waterLevelNoise, this.lavaNoise, this.settings.get(), this.sampler, startY * this.cellHeight, deltaY * this.cellHeight);
+        return !this.isAquifersEnabled() ? Aquifer.createDisabled(this.getSeaLevel(), this.defaultFluid) : Aquifer.create(pos, this.barrierNoise, this.waterLevelNoise, this.lavaNoise, (NoiseGeneratorSettings) this.settings.get(), this.sampler, startY * this.cellHeight, deltaY * this.cellHeight);
     }
 
-    protected BlockState updateNoiseAndGenerateBaseState(Beardifier structures, Aquifer aquiferSampler, BaseStoneSource blockInterpolator, NoiseModifier noiseModifier, int i, int j, int k, double d) {
-        double e = Mth.clamp(d / 200.0D, -1.0D, 1.0D);
-        e = e / 2.0D - e * e * e / 24.0D;
-        e = noiseModifier.modifyNoise(e, i, j, k);
-        e = e + structures.beardifyOrBury(i, j, k);
-        return aquiferSampler.computeState(blockInterpolator, i, j, k, e);
+    protected BlockState updateNoiseAndGenerateBaseState(Beardifier structures, Aquifer aquiferSampler, BaseStoneSource blockInterpolator, NoiseModifier noisemodifier, int i, int j, int k, double d0) {
+        double d1 = Mth.clamp(d0 / 200.0D, -1.0D, 1.0D);
+
+        d1 = d1 / 2.0D - d1 * d1 * d1 / 24.0D;
+        d1 = noisemodifier.modifyNoise(d1, i, j, k);
+        d1 += structures.beardifyOrBury(i, j, k);
+        return aquiferSampler.computeState(blockInterpolator, i, j, k, d1);
     }
 
     @Override
     public void buildSurfaceAndBedrock(WorldGenRegion region, ChunkAccess chunk) {
-        ChunkPos chunkPos = chunk.getPos();
-        int i = chunkPos.x;
-        int j = chunkPos.z;
-        WorldgenRandom worldgenRandom = new WorldgenRandom();
-        worldgenRandom.setBaseChunkSeed(i, j);
-        ChunkPos chunkPos2 = chunk.getPos();
-        int k = chunkPos2.getMinBlockX();
-        int l = chunkPos2.getMinBlockZ();
-        double d = 0.0625D;
-        BlockPos.MutableBlockPos mutableBlockPos = new BlockPos.MutableBlockPos();
+        // CraftBukkit start - spilt surface and bedrock generation code
+        Random random = this.buildSurface(region, chunk);
+        this.buildBedrock(chunk, random);
+    }
 
-        for(int m = 0; m < 16; ++m) {
-            for(int n = 0; n < 16; ++n) {
-                int o = k + m;
-                int p = l + n;
-                int q = chunk.getHeight(Heightmap.Types.WORLD_SURFACE_WG, m, n) + 1;
-                double e = this.surfaceNoise.getSurfaceNoiseValue((double)o * 0.0625D, (double)p * 0.0625D, 0.0625D, (double)m * 0.0625D) * 15.0D;
-                int r = this.settings.get().getMinSurfaceLevel();
-                region.getBiome(mutableBlockPos.set(k + m, q, l + n)).buildSurfaceAt(worldgenRandom, chunk, o, p, q, e, this.defaultBlock, this.defaultFluid, this.getSeaLevel(), r, region.getSeed());
+    @Override
+    public void buildBedrock(ChunkAccess iChunkAccess, Random random) {
+        this.setBedrock(iChunkAccess, random); // PAIL rename setBedrock
+    }
+
+    @Override
+    public WorldgenRandom buildSurface(WorldGenRegion regionlimitedworldaccess, ChunkAccess ichunkaccess) {
+        // CraftBukkit end
+        ChunkPos chunkcoordintpair = ichunkaccess.getPos();
+        int i = chunkcoordintpair.x;
+        int j = chunkcoordintpair.z;
+        WorldgenRandom seededrandom = new WorldgenRandom();
+
+        seededrandom.setBaseChunkSeed(i, j);
+        ChunkPos chunkcoordintpair1 = ichunkaccess.getPos();
+        int k = chunkcoordintpair1.getMinBlockX();
+        int l = chunkcoordintpair1.getMinBlockZ();
+        double d0 = 0.0625D;
+        BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos();
+
+        for (int i1 = 0; i1 < 16; ++i1) {
+            for (int j1 = 0; j1 < 16; ++j1) {
+                int k1 = k + i1;
+                int l1 = l + j1;
+                int i2 = ichunkaccess.getHeight(Heightmap.Types.WORLD_SURFACE_WG, i1, j1) + 1;
+                double d1 = this.surfaceNoise.getSurfaceNoiseValue((double) k1 * 0.0625D, (double) l1 * 0.0625D, 0.0625D, (double) i1 * 0.0625D) * 15.0D;
+                int j2 = ((NoiseGeneratorSettings) this.settings.get()).getMinSurfaceLevel();
+
+                regionlimitedworldaccess.getBiome(blockposition_mutableblockposition.set(k + i1, i2, l + j1)).buildSurfaceAt(seededrandom, ichunkaccess, k1, l1, i2, d1, this.defaultBlock, this.defaultFluid, this.getSeaLevel(), j2, regionlimitedworldaccess.getSeed());
             }
         }
 
-        this.setBedrock(chunk, worldgenRandom);
+        // CraftBukkit start - spilt surface and bedrock generation code
+        // this.a(ichunkaccess, seededrandom);
+        return seededrandom;
+        // CraftBukkit end
     }
 
     private void setBedrock(ChunkAccess chunk, Random random) {
-        BlockPos.MutableBlockPos mutableBlockPos = new BlockPos.MutableBlockPos();
+        BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos();
         int i = chunk.getPos().getMinBlockX();
         int j = chunk.getPos().getMinBlockZ();
-        NoiseGeneratorSettings noiseGeneratorSettings = this.settings.get();
-        int k = noiseGeneratorSettings.noiseSettings().minY();
-        int l = k + noiseGeneratorSettings.getBedrockFloorPosition();
-        int m = this.height - 1 + k - noiseGeneratorSettings.getBedrockRoofPosition();
-        int n = 5;
-        int o = chunk.getMinBuildHeight();
-        int p = chunk.getMaxBuildHeight();
-        boolean bl = m + 5 - 1 >= o && m < p;
-        boolean bl2 = l + 5 - 1 >= o && l < p;
-        if (bl || bl2) {
-            for(BlockPos blockPos : BlockPos.betweenClosed(i, 0, j, i + 15, 0, j + 15)) {
-                if (bl) {
-                    for(int q = 0; q < 5; ++q) {
-                        if (q <= random.nextInt(5)) {
-                            chunk.setBlockState(mutableBlockPos.set(blockPos.getX(), m - q, blockPos.getZ()), Blocks.BEDROCK.defaultBlockState(), false);
+        NoiseGeneratorSettings generatorsettingbase = (NoiseGeneratorSettings) this.settings.get();
+        int k = generatorsettingbase.noiseSettings().minY();
+        int l = k + generatorsettingbase.getBedrockFloorPosition();
+        int i1 = this.height - 1 + k - generatorsettingbase.getBedrockRoofPosition();
+        boolean flag = true;
+        int j1 = chunk.getMinBuildHeight();
+        int k1 = chunk.getMaxBuildHeight();
+        boolean flag1 = i1 + 5 - 1 >= j1 && i1 < k1;
+        boolean flag2 = l + 5 - 1 >= j1 && l < k1;
+
+        if (flag1 || flag2) {
+            Iterator iterator = BlockPos.betweenClosed(i, 0, j, i + 15, 0, j + 15).iterator();
+
+            while (iterator.hasNext()) {
+                BlockPos blockposition = (BlockPos) iterator.next();
+                int l1;
+
+                if (flag1) {
+                    for (l1 = 0; l1 < 5; ++l1) {
+                        if (l1 <= (chunk.generateFlatBedrock() ? 0 : random.nextInt(5))) { // Paper - Configurable flat bedrock roof
+                            chunk.setBlockState(blockposition_mutableblockposition.set(blockposition.getX(), i1 - l1, blockposition.getZ()), Blocks.BEDROCK.defaultBlockState(), false);
                         }
                     }
                 }
 
-                if (bl2) {
-                    for(int r = 4; r >= 0; --r) {
-                        if (r <= random.nextInt(5)) {
-                            chunk.setBlockState(mutableBlockPos.set(blockPos.getX(), l + r, blockPos.getZ()), Blocks.BEDROCK.defaultBlockState(), false);
+                if (flag2) {
+                    for (l1 = 4; l1 >= 0; --l1) {
+                        if (l1 <= (chunk.generateFlatBedrock() ? 0 : random.nextInt(5))) { // Paper - Configurable flat bedrock floor{
+                            chunk.setBlockState(blockposition_mutableblockposition.set(blockposition.getX(), l + l1, blockposition.getZ()), Blocks.BEDROCK.defaultBlockState(), false);
                         }
                     }
                 }
@@ -301,111 +343,144 @@
 
     @Override
     public CompletableFuture<ChunkAccess> fillFromNoise(Executor executor, StructureFeatureManager accessor, ChunkAccess chunk) {
-        NoiseSettings noiseSettings = this.settings.get().noiseSettings();
-        int i = Math.max(noiseSettings.minY(), chunk.getMinBuildHeight());
-        int j = Math.min(noiseSettings.minY() + noiseSettings.height(), chunk.getMaxBuildHeight());
+        NoiseSettings noisesettings = ((NoiseGeneratorSettings) this.settings.get()).noiseSettings();
+        int i = Math.max(noisesettings.minY(), chunk.getMinBuildHeight());
+        int j = Math.min(noisesettings.minY() + noisesettings.height(), chunk.getMaxBuildHeight());
         int k = Mth.intFloorDiv(i, this.cellHeight);
         int l = Mth.intFloorDiv(j - i, this.cellHeight);
+
         if (l <= 0) {
             return CompletableFuture.completedFuture(chunk);
         } else {
-            int m = chunk.getSectionIndex(l * this.cellHeight - 1 + i);
-            int n = chunk.getSectionIndex(i);
+            int i1 = chunk.getSectionIndex(l * this.cellHeight - 1 + i);
+            int j1 = chunk.getSectionIndex(i);
+
             return CompletableFuture.supplyAsync(() -> {
-                Set<LevelChunkSection> set = Sets.newHashSet();
+                HashSet hashset = Sets.newHashSet();
+                boolean flag = false;
+
+                ChunkAccess ichunkaccess1;
 
-                ChunkAccess var16;
                 try {
-                    for(int m = m; m >= n; --m) {
-                        LevelChunkSection levelChunkSection = chunk.getOrCreateSection(m);
-                        levelChunkSection.acquire();
-                        set.add(levelChunkSection);
+                    flag = true;
+
+                    for (int k1 = i1; k1 >= j1; --k1) {
+                        LevelChunkSection chunksection = chunk.getOrCreateSection(k1);
+
+                        chunksection.acquire();
+                        hashset.add(chunksection);
                     }
 
-                    var16 = this.doFill(accessor, chunk, k, l);
+                    ichunkaccess1 = this.doFill(accessor, chunk, k, l);
+                    flag = false;
                 } finally {
-                    for(LevelChunkSection levelChunkSection3 : set) {
-                        levelChunkSection3.release();
+                    if (flag) {
+                        Iterator iterator = hashset.iterator();
+
+                        while (iterator.hasNext()) {
+                            LevelChunkSection chunksection1 = (LevelChunkSection) iterator.next();
+
+                            chunksection1.release();
+                        }
+
                     }
+                }
+
+                Iterator iterator1 = hashset.iterator();
 
+                while (iterator1.hasNext()) {
+                    LevelChunkSection chunksection2 = (LevelChunkSection) iterator1.next();
+
+                    chunksection2.release();
                 }
 
-                return var16;
+                return ichunkaccess1;
             }, Util.backgroundExecutor());
         }
     }
 
     private ChunkAccess doFill(StructureFeatureManager accessor, ChunkAccess chunk, int startY, int noiseSizeY) {
         Heightmap heightmap = chunk.getOrCreateHeightmapUnprimed(Heightmap.Types.OCEAN_FLOOR_WG);
-        Heightmap heightmap2 = chunk.getOrCreateHeightmapUnprimed(Heightmap.Types.WORLD_SURFACE_WG);
-        ChunkPos chunkPos = chunk.getPos();
-        int i = chunkPos.getMinBlockX();
-        int j = chunkPos.getMinBlockZ();
+        Heightmap heightmap1 = chunk.getOrCreateHeightmapUnprimed(Heightmap.Types.WORLD_SURFACE_WG);
+        ChunkPos chunkcoordintpair = chunk.getPos();
+        int k = chunkcoordintpair.getMinBlockX();
+        int l = chunkcoordintpair.getMinBlockZ();
         Beardifier beardifier = new Beardifier(accessor, chunk);
-        Aquifer aquifer = this.getAquifer(startY, noiseSizeY, chunkPos);
-        NoiseInterpolator noiseInterpolator = new NoiseInterpolator(this.cellCountX, noiseSizeY, this.cellCountZ, chunkPos, startY, this::fillNoiseColumn);
-        List<NoiseInterpolator> list = Lists.newArrayList(noiseInterpolator);
+        Aquifer aquifer = this.getAquifer(startY, noiseSizeY, chunkcoordintpair);
+        NoiseInterpolator noiseinterpolator = new NoiseInterpolator(this.cellCountX, noiseSizeY, this.cellCountZ, chunkcoordintpair, startY, this::fillNoiseColumn);
+        List<NoiseInterpolator> list = Lists.newArrayList(new NoiseInterpolator[]{noiseinterpolator});
+
+        Objects.requireNonNull(list);
         Consumer<NoiseInterpolator> consumer = list::add;
-        DoubleFunction<BaseStoneSource> doubleFunction = this.createBaseStoneSource(startY, chunkPos, consumer);
-        DoubleFunction<NoiseModifier> doubleFunction2 = this.createCaveNoiseModifier(startY, chunkPos, consumer);
+        DoubleFunction<BaseStoneSource> doublefunction = this.createBaseStoneSource(startY, chunkcoordintpair, consumer);
+        DoubleFunction<NoiseModifier> doublefunction1 = this.createCaveNoiseModifier(startY, chunkcoordintpair, consumer);
+
         list.forEach(NoiseInterpolator::initializeForFirstCellX);
-        BlockPos.MutableBlockPos mutableBlockPos = new BlockPos.MutableBlockPos();
+        BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos();
 
-        for(int k = 0; k < this.cellCountX; ++k) {
-            int l = k;
-            list.forEach((noiseInterpolatorx) -> {
-                noiseInterpolatorx.advanceCellX(l);
+        for (int i1 = 0; i1 < this.cellCountX; ++i1) {
+            // CraftBukkit start - decompile error
+            int i1Final = i1;
+            list.forEach((noiseinterpolator1) -> {
+                noiseinterpolator1.advanceCellX(i1Final);
+                // CraftBukkit end
             });
 
-            for(int m = 0; m < this.cellCountZ; ++m) {
-                LevelChunkSection levelChunkSection = chunk.getOrCreateSection(chunk.getSectionsCount() - 1);
+            for (int j1 = 0; j1 < this.cellCountZ; ++j1) {
+                LevelChunkSection chunksection = chunk.getOrCreateSection(chunk.getSectionsCount() - 1);
 
-                for(int n = noiseSizeY - 1; n >= 0; --n) {
-                    int o = m;
-                    int p = n;
-                    list.forEach((noiseInterpolatorx) -> {
-                        noiseInterpolatorx.selectCellYZ(p, o);
+                for (int k1 = noiseSizeY - 1; k1 >= 0; --k1) {
+                    // CraftBukkit start - decompile error
+                    int kiFinal = k1;
+                    int j1Final = j1;
+                    list.forEach((noiseinterpolator1) -> {
+                        noiseinterpolator1.selectCellYZ(kiFinal, j1Final);
+                        // CraftBukkit end
                     });
 
-                    for(int q = this.cellHeight - 1; q >= 0; --q) {
-                        int r = (startY + n) * this.cellHeight + q;
-                        int s = r & 15;
-                        int t = chunk.getSectionIndex(r);
-                        if (chunk.getSectionIndex(levelChunkSection.bottomBlockY()) != t) {
-                            levelChunkSection = chunk.getOrCreateSection(t);
+                    for (int l1 = this.cellHeight - 1; l1 >= 0; --l1) {
+                        int i2 = (startY + k1) * this.cellHeight + l1;
+                        int j2 = i2 & 15;
+                        int k2 = chunk.getSectionIndex(i2);
+
+                        if (chunk.getSectionIndex(chunksection.bottomBlockY()) != k2) {
+                            chunksection = chunk.getOrCreateSection(k2);
                         }
 
-                        double d = (double)q / (double)this.cellHeight;
-                        list.forEach((noiseInterpolatorx) -> {
-                            noiseInterpolatorx.updateForY(d);
+                        double d0 = (double) l1 / (double) this.cellHeight;
+
+                        list.forEach((noiseinterpolator1) -> {
+                            noiseinterpolator1.updateForY(d0);
                         });
 
-                        for(int u = 0; u < this.cellWidth; ++u) {
-                            int v = i + k * this.cellWidth + u;
-                            int w = v & 15;
-                            double e = (double)u / (double)this.cellWidth;
-                            list.forEach((noiseInterpolatorx) -> {
-                                noiseInterpolatorx.updateForX(e);
+                        for (int l2 = 0; l2 < this.cellWidth; ++l2) {
+                            int i3 = k + i1 * this.cellWidth + l2;
+                            int j3 = i3 & 15;
+                            double d1 = (double) l2 / (double) this.cellWidth;
+
+                            list.forEach((noiseinterpolator1) -> {
+                                noiseinterpolator1.updateForX(d1);
                             });
 
-                            for(int x = 0; x < this.cellWidth; ++x) {
-                                int y = j + m * this.cellWidth + x;
-                                int z = y & 15;
-                                double f = (double)x / (double)this.cellWidth;
-                                double g = noiseInterpolator.calculateValue(f);
-                                BlockState blockState = this.updateNoiseAndGenerateBaseState(beardifier, aquifer, doubleFunction.apply(f), doubleFunction2.apply(f), v, r, y, g);
-                                if (blockState != AIR) {
-                                    if (blockState.getLightEmission() != 0 && chunk instanceof ProtoChunk) {
-                                        mutableBlockPos.set(v, r, y);
-                                        ((ProtoChunk)chunk).addLight(mutableBlockPos);
+                            for (int k3 = 0; k3 < this.cellWidth; ++k3) {
+                                int l3 = l + j1 * this.cellWidth + k3;
+                                int i4 = l3 & 15;
+                                double d2 = (double) k3 / (double) this.cellWidth;
+                                double d3 = noiseinterpolator.calculateValue(d2);
+                                BlockState iblockdata = this.updateNoiseAndGenerateBaseState(beardifier, aquifer, (BaseStoneSource) doublefunction.apply(d2), (NoiseModifier) doublefunction1.apply(d2), i3, i2, l3, d3);
+
+                                if (iblockdata != NoiseBasedChunkGenerator.AIR) {
+                                    if (iblockdata.getLightEmission() != 0 && chunk instanceof ProtoChunk) {
+                                        blockposition_mutableblockposition.set(i3, i2, l3);
+                                        ((ProtoChunk) chunk).addLight(blockposition_mutableblockposition);
                                     }
 
-                                    levelChunkSection.setBlockState(w, s, z, blockState, false);
-                                    heightmap.update(w, r, z, blockState);
-                                    heightmap2.update(w, r, z, blockState);
-                                    if (aquifer.shouldScheduleFluidUpdate() && !blockState.getFluidState().isEmpty()) {
-                                        mutableBlockPos.set(v, r, y);
-                                        chunk.getLiquidTicks().scheduleTick(mutableBlockPos, blockState.getFluidState().getType(), 0);
+                                    chunksection.setBlockState(j3, j2, i4, iblockdata, false);
+                                    heightmap.update(j3, i2, i4, iblockdata);
+                                    heightmap1.update(j3, i2, i4, iblockdata);
+                                    if (aquifer.shouldScheduleFluidUpdate() && !iblockdata.getFluidState().isEmpty()) {
+                                        blockposition_mutableblockposition.set(i3, i2, l3);
+                                        chunk.getLiquidTicks().scheduleTick(blockposition_mutableblockposition, iblockdata.getFluidState().getType(), 0);
                                     }
                                 }
                             }
@@ -421,42 +496,48 @@
     }
 
     private DoubleFunction<NoiseModifier> createCaveNoiseModifier(int minY, ChunkPos pos, Consumer<NoiseInterpolator> consumer) {
-        if (!this.settings.get().isNoodleCavesEnabled()) {
-            return (d) -> {
+        if (!((NoiseGeneratorSettings) this.settings.get()).isNoodleCavesEnabled()) {
+            return (d0) -> {
                 return NoiseModifier.PASSTHROUGH;
             };
         } else {
-            NoiseBasedChunkGenerator.NoodleCaveNoiseModifier noodleCaveNoiseModifier = new NoiseBasedChunkGenerator.NoodleCaveNoiseModifier(pos, minY);
-            noodleCaveNoiseModifier.listInterpolators(consumer);
-            return noodleCaveNoiseModifier::prepare;
+            NoiseBasedChunkGenerator.NoodleCaveNoiseModifier chunkgeneratorabstract_a = new NoiseBasedChunkGenerator.NoodleCaveNoiseModifier(pos, minY);
+
+            chunkgeneratorabstract_a.listInterpolators(consumer);
+            Objects.requireNonNull(chunkgeneratorabstract_a);
+            return chunkgeneratorabstract_a::prepare;
         }
     }
 
     private DoubleFunction<BaseStoneSource> createBaseStoneSource(int minY, ChunkPos pos, Consumer<NoiseInterpolator> consumer) {
-        if (!this.settings.get().isOreVeinsEnabled()) {
-            return (d) -> {
+        if (!((NoiseGeneratorSettings) this.settings.get()).isOreVeinsEnabled()) {
+            return (d0) -> {
                 return this.baseStoneSource;
             };
         } else {
-            NoiseBasedChunkGenerator.OreVeinNoiseSource oreVeinNoiseSource = new NoiseBasedChunkGenerator.OreVeinNoiseSource(pos, minY, this.seed + 1L);
-            oreVeinNoiseSource.listInterpolators(consumer);
-            BaseStoneSource baseStoneSource = (i, j, k) -> {
-                BlockState blockState = oreVeinNoiseSource.getBaseBlock(i, j, k);
-                return blockState != this.defaultBlock ? blockState : this.baseStoneSource.getBaseBlock(i, j, k);
+            NoiseBasedChunkGenerator.OreVeinNoiseSource chunkgeneratorabstract_b = new NoiseBasedChunkGenerator.OreVeinNoiseSource(pos, minY, this.seed + 1L);
+
+            chunkgeneratorabstract_b.listInterpolators(consumer);
+            BaseStoneSource basestonesource = (j, k, l) -> {
+                BlockState iblockdata = chunkgeneratorabstract_b.getBaseBlock(j, k, l);
+
+                return iblockdata != this.defaultBlock ? iblockdata : this.baseStoneSource.getBaseBlock(j, k, l);
             };
-            return (deltaZ) -> {
-                oreVeinNoiseSource.prepare(deltaZ);
-                return baseStoneSource;
+
+            return (d0) -> {
+                chunkgeneratorabstract_b.prepare(d0);
+                return basestonesource;
             };
         }
     }
 
     @Override
     protected Aquifer createAquifer(ChunkAccess chunk) {
-        ChunkPos chunkPos = chunk.getPos();
-        int i = Math.max(this.settings.get().noiseSettings().minY(), chunk.getMinBuildHeight());
+        ChunkPos chunkcoordintpair = chunk.getPos();
+        int i = Math.max(((NoiseGeneratorSettings) this.settings.get()).noiseSettings().minY(), chunk.getMinBuildHeight());
         int j = Mth.intFloorDiv(i, this.cellHeight);
-        return this.getAquifer(j, this.cellCountY, chunkPos);
+
+        return this.getAquifer(j, this.cellCountY, chunkcoordintpair);
     }
 
     @Override
@@ -466,12 +547,12 @@
 
     @Override
     public int getSeaLevel() {
-        return this.settings.get().seaLevel();
+        return ((NoiseGeneratorSettings) this.settings.get()).seaLevel();
     }
 
     @Override
     public int getMinY() {
-        return this.settings.get().noiseSettings().minY();
+        return ((NoiseGeneratorSettings) this.settings.get()).noiseSettings().minY();
     }
 
     @Override
@@ -505,27 +586,50 @@
 
     @Override
     public void spawnOriginalMobs(WorldGenRegion region) {
-        if (!this.settings.get().disableMobGeneration()) {
-            ChunkPos chunkPos = region.getCenter();
-            Biome biome = region.getBiome(chunkPos.getWorldPosition());
-            WorldgenRandom worldgenRandom = new WorldgenRandom();
-            worldgenRandom.setDecorationSeed(region.getSeed(), chunkPos.getMinBlockX(), chunkPos.getMinBlockZ());
-            NaturalSpawner.spawnMobsForChunkGeneration(region, biome, chunkPos, worldgenRandom);
+        if (!((NoiseGeneratorSettings) this.settings.get()).disableMobGeneration()) {
+            ChunkPos chunkcoordintpair = region.getCenter();
+            Biome biomebase = region.getBiome(chunkcoordintpair.getWorldPosition());
+            WorldgenRandom seededrandom = new WorldgenRandom();
+
+            seededrandom.setDecorationSeed(region.getSeed(), chunkcoordintpair.getMinBlockX(), chunkcoordintpair.getMinBlockZ());
+            NaturalSpawner.spawnMobsForChunkGeneration((ServerLevelAccessor) region, biomebase, chunkcoordintpair, (Random) seededrandom);
         }
     }
 
-    class NoodleCaveNoiseModifier implements NoiseModifier {
+    private class NoodleCaveNoiseModifier implements NoiseModifier {
+
         private final NoiseInterpolator toggle;
         private final NoiseInterpolator thickness;
         private final NoiseInterpolator ridgeA;
         private final NoiseInterpolator ridgeB;
         private double factorZ;
 
-        public NoodleCaveNoiseModifier(ChunkPos pos, int minY) {
-            this.toggle = new NoiseInterpolator(NoiseBasedChunkGenerator.this.cellCountX, NoiseBasedChunkGenerator.this.cellCountY, NoiseBasedChunkGenerator.this.cellCountZ, pos, minY, NoiseBasedChunkGenerator.this.noodleCavifier::fillToggleNoiseColumn);
-            this.thickness = new NoiseInterpolator(NoiseBasedChunkGenerator.this.cellCountX, NoiseBasedChunkGenerator.this.cellCountY, NoiseBasedChunkGenerator.this.cellCountZ, pos, minY, NoiseBasedChunkGenerator.this.noodleCavifier::fillThicknessNoiseColumn);
-            this.ridgeA = new NoiseInterpolator(NoiseBasedChunkGenerator.this.cellCountX, NoiseBasedChunkGenerator.this.cellCountY, NoiseBasedChunkGenerator.this.cellCountZ, pos, minY, NoiseBasedChunkGenerator.this.noodleCavifier::fillRidgeANoiseColumn);
-            this.ridgeB = new NoiseInterpolator(NoiseBasedChunkGenerator.this.cellCountX, NoiseBasedChunkGenerator.this.cellCountY, NoiseBasedChunkGenerator.this.cellCountZ, pos, minY, NoiseBasedChunkGenerator.this.noodleCavifier::fillRidgeBNoiseColumn);
+        public NoodleCaveNoiseModifier(ChunkPos chunkcoordintpair, int i) {
+            int j = NoiseBasedChunkGenerator.this.cellCountX;
+            int k = NoiseBasedChunkGenerator.this.cellCountY;
+            int l = NoiseBasedChunkGenerator.this.cellCountZ;
+            NoodleCavifier noodlecavifier = NoiseBasedChunkGenerator.this.noodleCavifier;
+
+            Objects.requireNonNull(NoiseBasedChunkGenerator.this.noodleCavifier);
+            this.toggle = new NoiseInterpolator(j, k, l, chunkcoordintpair, i, noodlecavifier::fillToggleNoiseColumn);
+            j = NoiseBasedChunkGenerator.this.cellCountX;
+            k = NoiseBasedChunkGenerator.this.cellCountY;
+            l = NoiseBasedChunkGenerator.this.cellCountZ;
+            noodlecavifier = NoiseBasedChunkGenerator.this.noodleCavifier;
+            Objects.requireNonNull(NoiseBasedChunkGenerator.this.noodleCavifier);
+            this.thickness = new NoiseInterpolator(j, k, l, chunkcoordintpair, i, noodlecavifier::fillThicknessNoiseColumn);
+            j = NoiseBasedChunkGenerator.this.cellCountX;
+            k = NoiseBasedChunkGenerator.this.cellCountY;
+            l = NoiseBasedChunkGenerator.this.cellCountZ;
+            noodlecavifier = NoiseBasedChunkGenerator.this.noodleCavifier;
+            Objects.requireNonNull(NoiseBasedChunkGenerator.this.noodleCavifier);
+            this.ridgeA = new NoiseInterpolator(j, k, l, chunkcoordintpair, i, noodlecavifier::fillRidgeANoiseColumn);
+            j = NoiseBasedChunkGenerator.this.cellCountX;
+            k = NoiseBasedChunkGenerator.this.cellCountY;
+            l = NoiseBasedChunkGenerator.this.cellCountZ;
+            noodlecavifier = NoiseBasedChunkGenerator.this.noodleCavifier;
+            Objects.requireNonNull(NoiseBasedChunkGenerator.this.noodleCavifier);
+            this.ridgeB = new NoiseInterpolator(j, k, l, chunkcoordintpair, i, noodlecavifier::fillRidgeBNoiseColumn);
         }
 
         public NoiseModifier prepare(double deltaZ) {
@@ -535,11 +639,12 @@
 
         @Override
         public double modifyNoise(double weight, int x, int y, int z) {
-            double d = this.toggle.calculateValue(this.factorZ);
-            double e = this.thickness.calculateValue(this.factorZ);
-            double f = this.ridgeA.calculateValue(this.factorZ);
-            double g = this.ridgeB.calculateValue(this.factorZ);
-            return NoiseBasedChunkGenerator.this.noodleCavifier.noodleCavify(weight, x, y, z, d, e, f, g, NoiseBasedChunkGenerator.this.getMinY());
+            double d1 = this.toggle.calculateValue(this.factorZ);
+            double d2 = this.thickness.calculateValue(this.factorZ);
+            double d3 = this.ridgeA.calculateValue(this.factorZ);
+            double d4 = this.ridgeB.calculateValue(this.factorZ);
+
+            return NoiseBasedChunkGenerator.this.noodleCavifier.noodleCavify(weight, x, y, z, d1, d2, d3, d4, NoiseBasedChunkGenerator.this.getMinY());
         }
 
         public void listInterpolators(Consumer<NoiseInterpolator> f) {
@@ -550,7 +655,8 @@
         }
     }
 
-    class OreVeinNoiseSource implements BaseStoneSource {
+    private class OreVeinNoiseSource implements BaseStoneSource {
+
         private final NoiseInterpolator veininess;
         private final NoiseInterpolator veinA;
         private final NoiseInterpolator veinB;
@@ -558,11 +664,27 @@
         private final long seed;
         private final WorldgenRandom random = new WorldgenRandom();
 
-        public OreVeinNoiseSource(ChunkPos pos, int minY, long seed) {
-            this.veininess = new NoiseInterpolator(NoiseBasedChunkGenerator.this.cellCountX, NoiseBasedChunkGenerator.this.cellCountY, NoiseBasedChunkGenerator.this.cellCountZ, pos, minY, NoiseBasedChunkGenerator.this.oreVeinifier::fillVeininessNoiseColumn);
-            this.veinA = new NoiseInterpolator(NoiseBasedChunkGenerator.this.cellCountX, NoiseBasedChunkGenerator.this.cellCountY, NoiseBasedChunkGenerator.this.cellCountZ, pos, minY, NoiseBasedChunkGenerator.this.oreVeinifier::fillNoiseColumnA);
-            this.veinB = new NoiseInterpolator(NoiseBasedChunkGenerator.this.cellCountX, NoiseBasedChunkGenerator.this.cellCountY, NoiseBasedChunkGenerator.this.cellCountZ, pos, minY, NoiseBasedChunkGenerator.this.oreVeinifier::fillNoiseColumnB);
-            this.seed = seed;
+        public OreVeinNoiseSource(ChunkPos chunkcoordintpair, int i, long j) {
+            int k = NoiseBasedChunkGenerator.this.cellCountX;
+            int l = NoiseBasedChunkGenerator.this.cellCountY;
+            int i1 = NoiseBasedChunkGenerator.this.cellCountZ;
+            OreVeinifier oreveinifier = NoiseBasedChunkGenerator.this.oreVeinifier;
+
+            Objects.requireNonNull(NoiseBasedChunkGenerator.this.oreVeinifier);
+            this.veininess = new NoiseInterpolator(k, l, i1, chunkcoordintpair, i, oreveinifier::fillVeininessNoiseColumn);
+            k = NoiseBasedChunkGenerator.this.cellCountX;
+            l = NoiseBasedChunkGenerator.this.cellCountY;
+            i1 = NoiseBasedChunkGenerator.this.cellCountZ;
+            oreveinifier = NoiseBasedChunkGenerator.this.oreVeinifier;
+            Objects.requireNonNull(NoiseBasedChunkGenerator.this.oreVeinifier);
+            this.veinA = new NoiseInterpolator(k, l, i1, chunkcoordintpair, i, oreveinifier::fillNoiseColumnA);
+            k = NoiseBasedChunkGenerator.this.cellCountX;
+            l = NoiseBasedChunkGenerator.this.cellCountY;
+            i1 = NoiseBasedChunkGenerator.this.cellCountZ;
+            oreveinifier = NoiseBasedChunkGenerator.this.oreVeinifier;
+            Objects.requireNonNull(NoiseBasedChunkGenerator.this.oreVeinifier);
+            this.veinB = new NoiseInterpolator(k, l, i1, chunkcoordintpair, i, oreveinifier::fillNoiseColumnB);
+            this.seed = j;
         }
 
         public void listInterpolators(Consumer<NoiseInterpolator> f) {
@@ -577,11 +699,12 @@
 
         @Override
         public BlockState getBaseBlock(int x, int y, int z) {
-            double d = this.veininess.calculateValue(this.factorZ);
-            double e = this.veinA.calculateValue(this.factorZ);
-            double f = this.veinB.calculateValue(this.factorZ);
+            double d0 = this.veininess.calculateValue(this.factorZ);
+            double d1 = this.veinA.calculateValue(this.factorZ);
+            double d2 = this.veinB.calculateValue(this.factorZ);
+
             this.random.setBaseStoneSeed(this.seed, x, y, z);
-            return NoiseBasedChunkGenerator.this.oreVeinifier.oreVeinify(this.random, x, y, z, d, e, f);
+            return NoiseBasedChunkGenerator.this.oreVeinifier.oreVeinify(this.random, x, y, z, d0, d1, d2);
         }
     }
 }
