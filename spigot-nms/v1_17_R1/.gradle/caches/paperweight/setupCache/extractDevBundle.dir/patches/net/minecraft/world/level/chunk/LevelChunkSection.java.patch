--- a/net/minecraft/world/level/chunk/LevelChunkSection.java
+++ b/net/minecraft/world/level/chunk/LevelChunkSection.java
@@ -15,21 +15,31 @@
     public static final int SECTION_SIZE = 4096;
     public static final Palette<BlockState> GLOBAL_BLOCKSTATE_PALETTE = new GlobalPalette<>(Block.BLOCK_STATE_REGISTRY, Blocks.AIR.defaultBlockState());
     private final int bottomBlockY;
-    private short nonEmptyBlockCount;
+    short nonEmptyBlockCount; // Paper - package-private
     private short tickingBlockCount;
     private short tickingFluidCount;
-    private final PalettedContainer<BlockState> states;
+    public final PalettedContainer<BlockState> states; // Paper - package-private // Paper - public
+    public final com.destroystokyo.paper.util.maplist.IBlockDataList tickingList = new com.destroystokyo.paper.util.maplist.IBlockDataList(); // Paper
 
-    public LevelChunkSection(int yOffset) {
-        this(yOffset, (short)0, (short)0, (short)0);
+    // Paper start - Anti-Xray - Add parameters
+    @Deprecated public LevelChunkSection(int yOffset) { this(yOffset, null, null, true); } // Notice for updates: Please make sure this constructor isn't used anywhere
+    public LevelChunkSection(int yOffset, ChunkAccess chunk, net.minecraft.world.level.Level level, boolean initializeBlocks) {
+        this(yOffset, (short) 0, (short) 0, (short) 0, chunk, level, initializeBlocks);
+        // Paper end
     }
 
-    public LevelChunkSection(int yOffset, short nonEmptyBlockCount, short randomTickableBlockCount, short nonEmptyFluidCount) {
+    // Paper start - Anti-Xray - Add parameters
+    @Deprecated public LevelChunkSection(int yOffset, short nonEmptyBlockCount, short randomTickableBlockCount, short nonEmptyFluidCount) { // Notice for updates: Please make sure this constructor isn't used anywhere
+        this(yOffset, nonEmptyBlockCount, randomTickableBlockCount, nonEmptyFluidCount, null, null, true);
+    }
+    public LevelChunkSection(int yOffset, short nonEmptyBlockCount, short randomTickableBlockCount, short nonEmptyFluidCount, ChunkAccess chunk, net.minecraft.world.level.Level level, boolean initializeBlocks) {
+        // Paper end
         this.bottomBlockY = getBottomBlockY(yOffset);
         this.nonEmptyBlockCount = nonEmptyBlockCount;
         this.tickingBlockCount = randomTickableBlockCount;
         this.tickingFluidCount = nonEmptyFluidCount;
-        this.states = new PalettedContainer<>(GLOBAL_BLOCKSTATE_PALETTE, Block.BLOCK_STATE_REGISTRY, NbtUtils::readBlockState, NbtUtils::writeBlockState, Blocks.AIR.defaultBlockState());
+        this.states = new PalettedContainer<>(GLOBAL_BLOCKSTATE_PALETTE, Block.BLOCK_STATE_REGISTRY, NbtUtils::readBlockState, NbtUtils::writeBlockState, Blocks.AIR.defaultBlockState(),
+            level == null ? null : level.chunkPacketBlockController.getPresetBlockStates(level, chunk, this, initializeBlocks), initializeBlocks); // Paper - Anti-Xray - Add preset block states
     }
 
     public static int getBottomBlockY(int chunkPos) {
@@ -37,11 +47,11 @@
     }
 
     public BlockState getBlockState(int x, int y, int z) {
-        return this.states.get(x, y, z);
+        return this.states.get(y << 8 | z << 4 | x); // Paper - inline
     }
 
     public FluidState getFluidState(int x, int y, int z) {
-        return this.states.get(x, y, z).getFluidState();
+        return this.states.get(x, y, z).getFluidState(); // Paper - diff on change - we expect this to be effectively just getType(x, y, z).getFluid(). If this changes we need to check other patches that use IBlockData#getFluid.
     }
 
     public void acquire() {
@@ -70,6 +80,9 @@
             --this.nonEmptyBlockCount;
             if (blockState.isRandomlyTicking()) {
                 --this.tickingBlockCount;
+                // Paper start
+                this.tickingList.remove(x, y, z);
+                // Paper end
             }
         }
 
@@ -81,6 +94,9 @@
             ++this.nonEmptyBlockCount;
             if (state.isRandomlyTicking()) {
                 ++this.tickingBlockCount;
+                // Paper start
+                this.tickingList.add(x, y, z, state);
+                // Paper end
             }
         }
 
@@ -116,22 +132,28 @@
     }
 
     public void recalcBlockCounts() {
+        // Paper start
+        this.tickingList.clear();
+        // Paper end
         this.nonEmptyBlockCount = 0;
         this.tickingBlockCount = 0;
         this.tickingFluidCount = 0;
-        this.states.count((state, count) -> {
+        this.states.forEachLocation((state, location) -> { // Paper
             FluidState fluidState = state.getFluidState();
             if (!state.isAir()) {
-                this.nonEmptyBlockCount = (short)(this.nonEmptyBlockCount + count);
+                this.nonEmptyBlockCount = (short)(this.nonEmptyBlockCount + 1); // Paper
                 if (state.isRandomlyTicking()) {
-                    this.tickingBlockCount = (short)(this.tickingBlockCount + count);
+                    // Paper start
+                    this.tickingBlockCount = (short)(this.tickingBlockCount + 1);
+                    this.tickingList.add(location, state);
+                    // Paper end
                 }
             }
 
             if (!fluidState.isEmpty()) {
-                this.nonEmptyBlockCount = (short)(this.nonEmptyBlockCount + count);
+                this.nonEmptyBlockCount = (short)(this.nonEmptyBlockCount + 1); // Paper
                 if (fluidState.isRandomlyTicking()) {
-                    this.tickingFluidCount = (short)(this.tickingFluidCount + count);
+                    this.tickingFluidCount = (short)(this.tickingFluidCount + 1); // Paper
                 }
             }
 
@@ -147,9 +169,12 @@
         this.states.read(buf);
     }
 
-    public void write(FriendlyByteBuf buf) {
+    // Paper start - Anti-Xray - Add chunk packet info
+    @Deprecated public void write(FriendlyByteBuf buf) { write(buf, null); } // Notice for updates: Please make sure this method isn't used anywhere
+    public void write(FriendlyByteBuf buf, com.destroystokyo.paper.antixray.ChunkPacketInfo<BlockState> chunkPacketInfo) {
+        // Paper end
         buf.writeShort(this.nonEmptyBlockCount);
-        this.states.write(buf);
+        this.states.write(buf, chunkPacketInfo, this.bottomBlockY); // Paper - Anti-Xray - Add chunk packet info
     }
 
     public int getSerializedSize() {
