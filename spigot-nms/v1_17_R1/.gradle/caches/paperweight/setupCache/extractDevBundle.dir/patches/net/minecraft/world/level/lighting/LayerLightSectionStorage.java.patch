--- a/net/minecraft/world/level/lighting/LayerLightSectionStorage.java
+++ b/net/minecraft/world/level/lighting/LayerLightSectionStorage.java
@@ -28,7 +28,7 @@
     protected final LongSet dataSectionSet = new LongOpenHashSet();
     protected final LongSet toMarkNoData = new LongOpenHashSet();
     protected final LongSet toMarkData = new LongOpenHashSet();
-    protected volatile M visibleSectionData;
+    protected volatile M e_visible; protected final Object visibleUpdateLock = new Object(); // Paper - diff on change, should be "visible" - force compile fail on usage change
     protected final M updatingSectionData;
     protected final LongSet changedSections = new LongOpenHashSet();
     protected final LongSet sectionsAffectedByLightUpdates = new LongOpenHashSet();
@@ -43,8 +43,8 @@
         this.layer = lightType;
         this.chunkSource = chunkProvider;
         this.updatingSectionData = lightData;
-        this.visibleSectionData = lightData.copy();
-        this.visibleSectionData.disableCache();
+        this.e_visible = lightData.copy(); // Paper - avoid copying light dat
+        this.e_visible.disableCache(); // Paper - avoid copying light dat
     }
 
     protected boolean storingLightForSection(long sectionPos) {
@@ -53,7 +53,15 @@
 
     @Nullable
     protected DataLayer getDataLayer(long sectionPos, boolean cached) {
-        return this.getDataLayer((M)(cached ? this.updatingSectionData : this.visibleSectionData), sectionPos);
+        // Paper start - avoid copying light data
+        if (cached) {
+            return this.getDataLayer(this.updatingSectionData, sectionPos);
+        } else {
+            synchronized (this.visibleUpdateLock) {
+                return this.getDataLayer(this.e_visible, sectionPos);
+            }
+        }
+        // Paper end - avoid copying light data
     }
 
     @Nullable
@@ -154,7 +162,7 @@
 
     protected DataLayer createDataLayer(long sectionPos) {
         DataLayer dataLayer = this.queuedSections.get(sectionPos);
-        return dataLayer != null ? dataLayer : new DataLayer();
+        return dataLayer != null ? dataLayer : new DataLayer().markPoolSafe(); // Paper
     }
 
     protected void clearQueuedSectionBlocks(LayerLightEngine<?, ?> storage, long sectionPos) {
@@ -313,12 +321,12 @@
 
     protected void queueSectionData(long sectionPos, @Nullable DataLayer array, boolean bl) {
         if (array != null) {
-            this.queuedSections.put(sectionPos, array);
+            DataLayer remove = this.queuedSections.put(sectionPos, array); if (remove != null && remove.cleaner != null) remove.cleaner.run(); // Paper - clean up when removed
             if (!bl) {
                 this.untrustedSections.add(sectionPos);
             }
         } else {
-            this.queuedSections.remove(sectionPos);
+            DataLayer remove = this.queuedSections.remove(sectionPos); if (remove != null && remove.cleaner != null) remove.cleaner.run(); // Paper - clean up when removed
         }
 
     }
@@ -346,9 +354,11 @@
 
     protected void swapSectionMap() {
         if (!this.changedSections.isEmpty()) {
+            synchronized (this.visibleUpdateLock) { // Paper - avoid copying light data
             M dataLayerStorageMap = this.updatingSectionData.copy();
             dataLayerStorageMap.disableCache();
-            this.visibleSectionData = dataLayerStorageMap;
+            this.e_visible = dataLayerStorageMap; // Paper - avoid copying light data
+            } // Paper - avoid copying light data
             this.changedSections.clear();
         }
 
